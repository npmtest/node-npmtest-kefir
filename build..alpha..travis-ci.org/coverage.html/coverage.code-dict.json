{"/home/travis/build/npmtest/node-npmtest-kefir/test.js":"/* istanbul instrument in package npmtest_kefir */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kefir/lib.npmtest_kefir.js":"/* istanbul instrument in package npmtest_kefir */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_kefir = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_kefir = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-kefir/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-kefir && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_kefir */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_kefir\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_kefir.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_kefir.rollup.js'] =\n            local.assetsDict['/assets.npmtest_kefir.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_kefir.__dirname + '/lib.npmtest_kefir.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/dist/kefir.js":"/*! Kefir.js v3.7.1\n *  https://github.com/rpominov/kefir\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.Kefir = global.Kefir || {})));\n}(this, function (exports) { 'use strict';\n\n\tfunction createObj(proto) {\n\t  var F = function () {};\n\t  F.prototype = proto;\n\t  return new F();\n\t}\n\n\tfunction extend(target /*, mixin1, mixin2...*/) {\n\t  var length = arguments.length,\n\t      i = void 0,\n\t      prop = void 0;\n\t  for (i = 1; i < length; i++) {\n\t    for (prop in arguments[i]) {\n\t      target[prop] = arguments[i][prop];\n\t    }\n\t  }\n\t  return target;\n\t}\n\n\tfunction inherit(Child, Parent /*, mixin1, mixin2...*/) {\n\t  var length = arguments.length,\n\t      i = void 0;\n\t  Child.prototype = createObj(Parent.prototype);\n\t  Child.prototype.constructor = Child;\n\t  for (i = 2; i < length; i++) {\n\t    extend(Child.prototype, arguments[i]);\n\t  }\n\t  return Child;\n\t}\n\n\tvar NOTHING = ['<nothing>'];\n\tvar END = 'end';\n\tvar VALUE = 'value';\n\tvar ERROR = 'error';\n\tvar ANY = 'any';\n\n\tfunction concat(a, b) {\n\t  var result = void 0,\n\t      length = void 0,\n\t      i = void 0,\n\t      j = void 0;\n\t  if (a.length === 0) {\n\t    return b;\n\t  }\n\t  if (b.length === 0) {\n\t    return a;\n\t  }\n\t  j = 0;\n\t  result = new Array(a.length + b.length);\n\t  length = a.length;\n\t  for (i = 0; i < length; i++, j++) {\n\t    result[j] = a[i];\n\t  }\n\t  length = b.length;\n\t  for (i = 0; i < length; i++, j++) {\n\t    result[j] = b[i];\n\t  }\n\t  return result;\n\t}\n\n\tfunction find(arr, value) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    if (arr[i] === value) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\tfunction findByPred(arr, pred) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    if (pred(arr[i])) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\tfunction cloneArray(input) {\n\t  var length = input.length,\n\t      result = new Array(length),\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    result[i] = input[i];\n\t  }\n\t  return result;\n\t}\n\n\tfunction remove(input, index) {\n\t  var length = input.length,\n\t      result = void 0,\n\t      i = void 0,\n\t      j = void 0;\n\t  if (index >= 0 && index < length) {\n\t    if (length === 1) {\n\t      return [];\n\t    } else {\n\t      result = new Array(length - 1);\n\t      for (i = 0, j = 0; i < length; i++) {\n\t        if (i !== index) {\n\t          result[j] = input[i];\n\t          j++;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t  } else {\n\t    return input;\n\t  }\n\t}\n\n\tfunction map(input, fn) {\n\t  var length = input.length,\n\t      result = new Array(length),\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    result[i] = fn(input[i]);\n\t  }\n\t  return result;\n\t}\n\n\tfunction forEach(arr, fn) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    fn(arr[i]);\n\t  }\n\t}\n\n\tfunction fillArray(arr, value) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    arr[i] = value;\n\t  }\n\t}\n\n\tfunction contains(arr, value) {\n\t  return find(arr, value) !== -1;\n\t}\n\n\tfunction slide(cur, next, max) {\n\t  var length = Math.min(max, cur.length + 1),\n\t      offset = cur.length - length + 1,\n\t      result = new Array(length),\n\t      i = void 0;\n\t  for (i = offset; i < length; i++) {\n\t    result[i - offset] = cur[i];\n\t  }\n\t  result[length - 1] = next;\n\t  return result;\n\t}\n\n\tfunction callSubscriber(type, fn, event) {\n\t  if (type === ANY) {\n\t    fn(event);\n\t  } else if (type === event.type) {\n\t    if (type === VALUE || type === ERROR) {\n\t      fn(event.value);\n\t    } else {\n\t      fn();\n\t    }\n\t  }\n\t}\n\n\tfunction Dispatcher() {\n\t  this._items = [];\n\t  this._spies = [];\n\t  this._inLoop = 0;\n\t  this._removedItems = null;\n\t}\n\n\textend(Dispatcher.prototype, {\n\t  add: function (type, fn) {\n\t    this._items = concat(this._items, [{ type: type, fn: fn }]);\n\t    return this._items.length;\n\t  },\n\t  remove: function (type, fn) {\n\t    var index = findByPred(this._items, function (x) {\n\t      return x.type === type && x.fn === fn;\n\t    });\n\n\t    // if we're currently in a notification loop,\n\t    // remember this subscriber was removed\n\t    if (this._inLoop !== 0 && index !== -1) {\n\t      if (this._removedItems === null) {\n\t        this._removedItems = [];\n\t      }\n\t      this._removedItems.push(this._items[index]);\n\t    }\n\n\t    this._items = remove(this._items, index);\n\t    return this._items.length;\n\t  },\n\t  addSpy: function (fn) {\n\t    this._spies = concat(this._spies, [fn]);\n\t    return this._spies.length;\n\t  },\n\n\n\t  // Because spies are only ever a function that perform logging as\n\t  // their only side effect, we don't need the same complicated\n\t  // removal logic like in remove()\n\t  removeSpy: function (fn) {\n\t    this._spies = remove(this._spies, this._spies.indexOf(fn));\n\t    return this._spies.length;\n\t  },\n\t  dispatch: function (event) {\n\t    this._inLoop++;\n\t    for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {\n\t      spies[i](event);\n\t    }\n\n\t    for (var _i = 0, items = this._items; _i < items.length; _i++) {\n\n\t      // cleanup was called\n\t      if (this._items === null) {\n\t        break;\n\t      }\n\n\t      // this subscriber was removed\n\t      if (this._removedItems !== null && contains(this._removedItems, items[_i])) {\n\t        continue;\n\t      }\n\n\t      callSubscriber(items[_i].type, items[_i].fn, event);\n\t    }\n\t    this._inLoop--;\n\t    if (this._inLoop === 0) {\n\t      this._removedItems = null;\n\t    }\n\t  },\n\t  cleanup: function () {\n\t    this._items = null;\n\t    this._spies = null;\n\t  }\n\t});\n\n\tfunction Observable() {\n\t  this._dispatcher = new Dispatcher();\n\t  this._active = false;\n\t  this._alive = true;\n\t  this._activating = false;\n\t  this._logHandlers = null;\n\t  this._spyHandlers = null;\n\t}\n\n\textend(Observable.prototype, {\n\n\t  _name: 'observable',\n\n\t  _onActivation: function () {},\n\t  _onDeactivation: function () {},\n\t  _setActive: function (active) {\n\t    if (this._active !== active) {\n\t      this._active = active;\n\t      if (active) {\n\t        this._activating = true;\n\t        this._onActivation();\n\t        this._activating = false;\n\t      } else {\n\t        this._onDeactivation();\n\t      }\n\t    }\n\t  },\n\t  _clear: function () {\n\t    this._setActive(false);\n\t    this._dispatcher.cleanup();\n\t    this._dispatcher = null;\n\t    this._logHandlers = null;\n\t  },\n\t  _emit: function (type, x) {\n\t    switch (type) {\n\t      case VALUE:\n\t        return this._emitValue(x);\n\t      case ERROR:\n\t        return this._emitError(x);\n\t      case END:\n\t        return this._emitEnd();\n\t    }\n\t  },\n\t  _emitValue: function (value) {\n\t    if (this._alive) {\n\t      this._dispatcher.dispatch({ type: VALUE, value: value });\n\t    }\n\t  },\n\t  _emitError: function (value) {\n\t    if (this._alive) {\n\t      this._dispatcher.dispatch({ type: ERROR, value: value });\n\t    }\n\t  },\n\t  _emitEnd: function () {\n\t    if (this._alive) {\n\t      this._alive = false;\n\t      this._dispatcher.dispatch({ type: END });\n\t      this._clear();\n\t    }\n\t  },\n\t  _on: function (type, fn) {\n\t    if (this._alive) {\n\t      this._dispatcher.add(type, fn);\n\t      this._setActive(true);\n\t    } else {\n\t      callSubscriber(type, fn, { type: END });\n\t    }\n\t    return this;\n\t  },\n\t  _off: function (type, fn) {\n\t    if (this._alive) {\n\t      var count = this._dispatcher.remove(type, fn);\n\t      if (count === 0) {\n\t        this._setActive(false);\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  onValue: function (fn) {\n\t    return this._on(VALUE, fn);\n\t  },\n\t  onError: function (fn) {\n\t    return this._on(ERROR, fn);\n\t  },\n\t  onEnd: function (fn) {\n\t    return this._on(END, fn);\n\t  },\n\t  onAny: function (fn) {\n\t    return this._on(ANY, fn);\n\t  },\n\t  offValue: function (fn) {\n\t    return this._off(VALUE, fn);\n\t  },\n\t  offError: function (fn) {\n\t    return this._off(ERROR, fn);\n\t  },\n\t  offEnd: function (fn) {\n\t    return this._off(END, fn);\n\t  },\n\t  offAny: function (fn) {\n\t    return this._off(ANY, fn);\n\t  },\n\t  observe: function (observerOrOnValue, onError, onEnd) {\n\t    var _this = this;\n\t    var closed = false;\n\n\t    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;\n\n\t    var handler = function (event) {\n\t      if (event.type === END) {\n\t        closed = true;\n\t      }\n\t      if (event.type === VALUE && observer.value) {\n\t        observer.value(event.value);\n\t      } else if (event.type === ERROR && observer.error) {\n\t        observer.error(event.value);\n\t      } else if (event.type === END && observer.end) {\n\t        observer.end(event.value);\n\t      }\n\t    };\n\n\t    this.onAny(handler);\n\n\t    return {\n\t      unsubscribe: function () {\n\t        if (!closed) {\n\t          _this.offAny(handler);\n\t          closed = true;\n\t        }\n\t      },\n\n\t      get closed() {\n\t        return closed;\n\t      }\n\t    };\n\t  },\n\n\n\t  // A and B must be subclasses of Stream and Property (order doesn't matter)\n\t  _ofSameType: function (A, B) {\n\t    return A.prototype.getType() === this.getType() ? A : B;\n\t  },\n\t  setName: function (sourceObs /* optional */, selfName) {\n\t    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;\n\t    return this;\n\t  },\n\t  log: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\n\t    var isCurrent = void 0;\n\t    var handler = function (event) {\n\t      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';\n\t      if (event.type === END) {\n\t        console.log(name, type);\n\t      } else {\n\t        console.log(name, type, event.value);\n\t      }\n\t    };\n\n\t    if (this._alive) {\n\t      if (!this._logHandlers) {\n\t        this._logHandlers = [];\n\t      }\n\t      this._logHandlers.push({ name: name, handler: handler });\n\t    }\n\n\t    isCurrent = true;\n\t    this.onAny(handler);\n\t    isCurrent = false;\n\n\t    return this;\n\t  },\n\t  offLog: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\n\t    if (this._logHandlers) {\n\t      var handlerIndex = findByPred(this._logHandlers, function (obj) {\n\t        return obj.name === name;\n\t      });\n\t      if (handlerIndex !== -1) {\n\t        this.offAny(this._logHandlers[handlerIndex].handler);\n\t        this._logHandlers.splice(handlerIndex, 1);\n\t      }\n\t    }\n\n\t    return this;\n\t  },\n\t  spy: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\t    var handler = function (event) {\n\t      var type = '<' + event.type + '>';\n\t      if (event.type === END) {\n\t        console.log(name, type);\n\t      } else {\n\t        console.log(name, type, event.value);\n\t      }\n\t    };\n\t    if (this._alive) {\n\t      if (!this._spyHandlers) {\n\t        this._spyHandlers = [];\n\t      }\n\t      this._spyHandlers.push({ name: name, handler: handler });\n\t      this._dispatcher.addSpy(handler);\n\t    }\n\t    return this;\n\t  },\n\t  offSpy: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\t    if (this._spyHandlers) {\n\t      var handlerIndex = findByPred(this._spyHandlers, function (obj) {\n\t        return obj.name === name;\n\t      });\n\t      if (handlerIndex !== -1) {\n\t        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);\n\t        this._spyHandlers.splice(handlerIndex, 1);\n\t      }\n\t    }\n\t    return this;\n\t  }\n\t});\n\n\t// extend() can't handle `toString` in IE8\n\tObservable.prototype.toString = function () {\n\t  return '[' + this._name + ']';\n\t};\n\n\tfunction Stream() {\n\t  Observable.call(this);\n\t}\n\n\tinherit(Stream, Observable, {\n\n\t  _name: 'stream',\n\n\t  getType: function () {\n\t    return 'stream';\n\t  }\n\t});\n\n\tfunction Property() {\n\t  Observable.call(this);\n\t  this._currentEvent = null;\n\t}\n\n\tinherit(Property, Observable, {\n\n\t  _name: 'property',\n\n\t  _emitValue: function (value) {\n\t    if (this._alive) {\n\t      this._currentEvent = { type: VALUE, value: value };\n\t      if (!this._activating) {\n\t        this._dispatcher.dispatch({ type: VALUE, value: value });\n\t      }\n\t    }\n\t  },\n\t  _emitError: function (value) {\n\t    if (this._alive) {\n\t      this._currentEvent = { type: ERROR, value: value };\n\t      if (!this._activating) {\n\t        this._dispatcher.dispatch({ type: ERROR, value: value });\n\t      }\n\t    }\n\t  },\n\t  _emitEnd: function () {\n\t    if (this._alive) {\n\t      this._alive = false;\n\t      if (!this._activating) {\n\t        this._dispatcher.dispatch({ type: END });\n\t      }\n\t      this._clear();\n\t    }\n\t  },\n\t  _on: function (type, fn) {\n\t    if (this._alive) {\n\t      this._dispatcher.add(type, fn);\n\t      this._setActive(true);\n\t    }\n\t    if (this._currentEvent !== null) {\n\t      callSubscriber(type, fn, this._currentEvent);\n\t    }\n\t    if (!this._alive) {\n\t      callSubscriber(type, fn, { type: END });\n\t    }\n\t    return this;\n\t  },\n\t  getType: function () {\n\t    return 'property';\n\t  }\n\t});\n\n\tvar neverS = new Stream();\n\tneverS._emitEnd();\n\tneverS._name = 'never';\n\n\tfunction never() {\n\t  return neverS;\n\t}\n\n\tfunction timeBased(mixin) {\n\n\t  function AnonymousStream(wait, options) {\n\t    var _this = this;\n\n\t    Stream.call(this);\n\t    this._wait = wait;\n\t    this._intervalId = null;\n\t    this._$onTick = function () {\n\t      return _this._onTick();\n\t    };\n\t    this._init(options);\n\t  }\n\n\t  inherit(AnonymousStream, Stream, {\n\t    _init: function () {},\n\t    _free: function () {},\n\t    _onTick: function () {},\n\t    _onActivation: function () {\n\t      this._intervalId = setInterval(this._$onTick, this._wait);\n\t    },\n\t    _onDeactivation: function () {\n\t      if (this._intervalId !== null) {\n\t        clearInterval(this._intervalId);\n\t        this._intervalId = null;\n\t      }\n\t    },\n\t    _clear: function () {\n\t      Stream.prototype._clear.call(this);\n\t      this._$onTick = null;\n\t      this._free();\n\t    }\n\t  }, mixin);\n\n\t  return AnonymousStream;\n\t}\n\n\tvar S = timeBased({\n\n\t  _name: 'later',\n\n\t  _init: function (_ref) {\n\t    var x = _ref.x;\n\n\t    this._x = x;\n\t  },\n\t  _free: function () {\n\t    this._x = null;\n\t  },\n\t  _onTick: function () {\n\t    this._emitValue(this._x);\n\t    this._emitEnd();\n\t  }\n\t});\n\n\tfunction later(wait, x) {\n\t  return new S(wait, { x: x });\n\t}\n\n\tvar S$1 = timeBased({\n\n\t  _name: 'interval',\n\n\t  _init: function (_ref) {\n\t    var x = _ref.x;\n\n\t    this._x = x;\n\t  },\n\t  _free: function () {\n\t    this._x = null;\n\t  },\n\t  _onTick: function () {\n\t    this._emitValue(this._x);\n\t  }\n\t});\n\n\tfunction interval(wait, x) {\n\t  return new S$1(wait, { x: x });\n\t}\n\n\tvar S$2 = timeBased({\n\n\t  _name: 'sequentially',\n\n\t  _init: function (_ref) {\n\t    var xs = _ref.xs;\n\n\t    this._xs = cloneArray(xs);\n\t  },\n\t  _free: function () {\n\t    this._xs = null;\n\t  },\n\t  _onTick: function () {\n\t    if (this._xs.length === 1) {\n\t      this._emitValue(this._xs[0]);\n\t      this._emitEnd();\n\t    } else {\n\t      this._emitValue(this._xs.shift());\n\t    }\n\t  }\n\t});\n\n\tfunction sequentially(wait, xs) {\n\t  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });\n\t}\n\n\tvar S$3 = timeBased({\n\n\t  _name: 'fromPoll',\n\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _onTick: function () {\n\t    var fn = this._fn;\n\t    this._emitValue(fn());\n\t  }\n\t});\n\n\tfunction fromPoll(wait, fn) {\n\t  return new S$3(wait, { fn: fn });\n\t}\n\n\tfunction emitter(obs) {\n\n\t  function value(x) {\n\t    obs._emitValue(x);\n\t    return obs._active;\n\t  }\n\n\t  function error(x) {\n\t    obs._emitError(x);\n\t    return obs._active;\n\t  }\n\n\t  function end() {\n\t    obs._emitEnd();\n\t    return obs._active;\n\t  }\n\n\t  function event(e) {\n\t    obs._emit(e.type, e.value);\n\t    return obs._active;\n\t  }\n\n\t  return {\n\t    value: value,\n\t    error: error,\n\t    end: end,\n\t    event: event,\n\n\t    // legacy\n\t    emit: value,\n\t    emitEvent: event\n\t  };\n\t}\n\n\tvar S$4 = timeBased({\n\n\t  _name: 'withInterval',\n\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t    this._emitter = emitter(this);\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t    this._emitter = null;\n\t  },\n\t  _onTick: function () {\n\t    var fn = this._fn;\n\t    fn(this._emitter);\n\t  }\n\t});\n\n\tfunction withInterval(wait, fn) {\n\t  return new S$4(wait, { fn: fn });\n\t}\n\n\tfunction S$5(fn) {\n\t  Stream.call(this);\n\t  this._fn = fn;\n\t  this._unsubscribe = null;\n\t}\n\n\tinherit(S$5, Stream, {\n\n\t  _name: 'stream',\n\n\t  _onActivation: function () {\n\t    var fn = this._fn;\n\t    var unsubscribe = fn(emitter(this));\n\t    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;\n\n\t    // fix https://github.com/rpominov/kefir/issues/35\n\t    if (!this._active) {\n\t      this._callUnsubscribe();\n\t    }\n\t  },\n\t  _callUnsubscribe: function () {\n\t    if (this._unsubscribe !== null) {\n\t      this._unsubscribe();\n\t      this._unsubscribe = null;\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    this._callUnsubscribe();\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._fn = null;\n\t  }\n\t});\n\n\tfunction stream(fn) {\n\t  return new S$5(fn);\n\t}\n\n\tfunction fromCallback(callbackConsumer) {\n\n\t  var called = false;\n\n\t  return stream(function (emitter) {\n\n\t    if (!called) {\n\t      callbackConsumer(function (x) {\n\t        emitter.emit(x);\n\t        emitter.end();\n\t      });\n\t      called = true;\n\t    }\n\t  }).setName('fromCallback');\n\t}\n\n\tfunction fromNodeCallback(callbackConsumer) {\n\n\t  var called = false;\n\n\t  return stream(function (emitter) {\n\n\t    if (!called) {\n\t      callbackConsumer(function (error, x) {\n\t        if (error) {\n\t          emitter.error(error);\n\t        } else {\n\t          emitter.emit(x);\n\t        }\n\t        emitter.end();\n\t      });\n\t      called = true;\n\t    }\n\t  }).setName('fromNodeCallback');\n\t}\n\n\tfunction spread(fn, length) {\n\t  switch (length) {\n\t    case 0:\n\t      return function () {\n\t        return fn();\n\t      };\n\t    case 1:\n\t      return function (a) {\n\t        return fn(a[0]);\n\t      };\n\t    case 2:\n\t      return function (a) {\n\t        return fn(a[0], a[1]);\n\t      };\n\t    case 3:\n\t      return function (a) {\n\t        return fn(a[0], a[1], a[2]);\n\t      };\n\t    case 4:\n\t      return function (a) {\n\t        return fn(a[0], a[1], a[2], a[3]);\n\t      };\n\t    default:\n\t      return function (a) {\n\t        return fn.apply(null, a);\n\t      };\n\t  }\n\t}\n\n\tfunction apply(fn, c, a) {\n\t  var aLength = a ? a.length : 0;\n\t  if (c == null) {\n\t    switch (aLength) {\n\t      case 0:\n\t        return fn();\n\t      case 1:\n\t        return fn(a[0]);\n\t      case 2:\n\t        return fn(a[0], a[1]);\n\t      case 3:\n\t        return fn(a[0], a[1], a[2]);\n\t      case 4:\n\t        return fn(a[0], a[1], a[2], a[3]);\n\t      default:\n\t        return fn.apply(null, a);\n\t    }\n\t  } else {\n\t    switch (aLength) {\n\t      case 0:\n\t        return fn.call(c);\n\t      default:\n\t        return fn.apply(c, a);\n\t    }\n\t  }\n\t}\n\n\tfunction fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n\t  return stream(function (emitter) {\n\n\t    var handler = transformer ? function () {\n\t      emitter.emit(apply(transformer, this, arguments));\n\t    } : function (x) {\n\t      emitter.emit(x);\n\t    };\n\n\t    sub(handler);\n\t    return function () {\n\t      return unsub(handler);\n\t    };\n\t  }).setName('fromSubUnsub');\n\t}\n\n\tvar pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];\n\n\tfunction fromEvents(target, eventName, transformer) {\n\t  var sub = void 0,\n\t      unsub = void 0;\n\n\t  for (var i = 0; i < pairs.length; i++) {\n\t    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n\t      sub = pairs[i][0];\n\t      unsub = pairs[i][1];\n\t      break;\n\t    }\n\t  }\n\n\t  if (sub === undefined) {\n\t    throw new Error('target don\\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n\t  }\n\n\t  return fromSubUnsub(function (handler) {\n\t    return target[sub](eventName, handler);\n\t  }, function (handler) {\n\t    return target[unsub](eventName, handler);\n\t  }, transformer).setName('fromEvents');\n\t}\n\n\t// HACK:\n\t//   We don't call parent Class constructor, but instead putting all necessary\n\t//   properties into prototype to simulate ended Property\n\t//   (see Propperty and Observable classes).\n\n\tfunction P(value) {\n\t  this._currentEvent = { type: 'value', value: value, current: true };\n\t}\n\n\tinherit(P, Property, {\n\t  _name: 'constant',\n\t  _active: false,\n\t  _activating: false,\n\t  _alive: false,\n\t  _dispatcher: null,\n\t  _logHandlers: null\n\t});\n\n\tfunction constant(x) {\n\t  return new P(x);\n\t}\n\n\t// HACK:\n\t//   We don't call parent Class constructor, but instead putting all necessary\n\t//   properties into prototype to simulate ended Property\n\t//   (see Propperty and Observable classes).\n\n\tfunction P$1(value) {\n\t  this._currentEvent = { type: 'error', value: value, current: true };\n\t}\n\n\tinherit(P$1, Property, {\n\t  _name: 'constantError',\n\t  _active: false,\n\t  _activating: false,\n\t  _alive: false,\n\t  _dispatcher: null,\n\t  _logHandlers: null\n\t});\n\n\tfunction constantError(x) {\n\t  return new P$1(x);\n\t}\n\n\tfunction createConstructor(BaseClass, name) {\n\t  return function AnonymousObservable(source, options) {\n\t    var _this = this;\n\n\t    BaseClass.call(this);\n\t    this._source = source;\n\t    this._name = source._name + '.' + name;\n\t    this._init(options);\n\t    this._$handleAny = function (event) {\n\t      return _this._handleAny(event);\n\t    };\n\t  };\n\t}\n\n\tfunction createClassMethods(BaseClass) {\n\t  return {\n\t    _init: function () {},\n\t    _free: function () {},\n\t    _handleValue: function (x) {\n\t      this._emitValue(x);\n\t    },\n\t    _handleError: function (x) {\n\t      this._emitError(x);\n\t    },\n\t    _handleEnd: function () {\n\t      this._emitEnd();\n\t    },\n\t    _handleAny: function (event) {\n\t      switch (event.type) {\n\t        case VALUE:\n\t          return this._handleValue(event.value);\n\t        case ERROR:\n\t          return this._handleError(event.value);\n\t        case END:\n\t          return this._handleEnd();\n\t      }\n\t    },\n\t    _onActivation: function () {\n\t      this._source.onAny(this._$handleAny);\n\t    },\n\t    _onDeactivation: function () {\n\t      this._source.offAny(this._$handleAny);\n\t    },\n\t    _clear: function () {\n\t      BaseClass.prototype._clear.call(this);\n\t      this._source = null;\n\t      this._$handleAny = null;\n\t      this._free();\n\t    }\n\t  };\n\t}\n\n\tfunction createStream(name, mixin) {\n\t  var S = createConstructor(Stream, name);\n\t  inherit(S, Stream, createClassMethods(Stream), mixin);\n\t  return S;\n\t}\n\n\tfunction createProperty(name, mixin) {\n\t  var P = createConstructor(Property, name);\n\t  inherit(P, Property, createClassMethods(Property), mixin);\n\t  return P;\n\t}\n\n\tvar P$2 = createProperty('toProperty', {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._getInitialCurrent = fn;\n\t  },\n\t  _onActivation: function () {\n\t    if (this._getInitialCurrent !== null) {\n\t      var getInitial = this._getInitialCurrent;\n\t      this._emitValue(getInitial());\n\t    }\n\t    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\t  }\n\t});\n\n\tfunction toProperty(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t  if (fn !== null && typeof fn !== 'function') {\n\t    throw new Error('You should call toProperty() with a function or no arguments.');\n\t  }\n\t  return new P$2(obs, { fn: fn });\n\t}\n\n\tvar S$6 = createStream('changes', {\n\t  _handleValue: function (x) {\n\t    if (!this._activating) {\n\t      this._emitValue(x);\n\t    }\n\t  },\n\t  _handleError: function (x) {\n\t    if (!this._activating) {\n\t      this._emitError(x);\n\t    }\n\t  }\n\t});\n\n\tfunction changes(obs) {\n\t  return new S$6(obs);\n\t}\n\n\tfunction fromPromise(promise) {\n\n\t  var called = false;\n\n\t  var result = stream(function (emitter) {\n\t    if (!called) {\n\t      var onValue = function (x) {\n\t        emitter.emit(x);\n\t        emitter.end();\n\t      };\n\t      var onError = function (x) {\n\t        emitter.error(x);\n\t        emitter.end();\n\t      };\n\t      var _promise = promise.then(onValue, onError);\n\n\t      // prevent libraries like 'Q' or 'when' from swallowing exceptions\n\t      if (_promise && typeof _promise.done === 'function') {\n\t        _promise.done();\n\t      }\n\n\t      called = true;\n\t    }\n\t  });\n\n\t  return toProperty(result, null).setName('fromPromise');\n\t}\n\n\tfunction getGlodalPromise() {\n\t  if (typeof Promise === 'function') {\n\t    return Promise;\n\t  } else {\n\t    throw new Error('There isn\\'t default Promise, use shim or parameter');\n\t  }\n\t}\n\n\tfunction toPromise (obs) {\n\t  var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();\n\n\t  var last = null;\n\t  return new Promise(function (resolve, reject) {\n\t    obs.onAny(function (event) {\n\t      if (event.type === END && last !== null) {\n\t        (last.type === VALUE ? resolve : reject)(last.value);\n\t        last = null;\n\t      } else {\n\t        last = event;\n\t      }\n\t    });\n\t  });\n\t}\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar ponyfill = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports['default'] = symbolObservablePonyfill;\n\tfunction symbolObservablePonyfill(root) {\n\t\tvar result;\n\t\tvar _Symbol = root.Symbol;\n\n\t\tif (typeof _Symbol === 'function') {\n\t\t\tif (_Symbol.observable) {\n\t\t\t\tresult = _Symbol.observable;\n\t\t\t} else {\n\t\t\t\tresult = _Symbol('observable');\n\t\t\t\t_Symbol.observable = result;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = '@@observable';\n\t\t}\n\n\t\treturn result;\n\t};\n\t});\n\n\tvar require$$0$1 = (ponyfill && typeof ponyfill === 'object' && 'default' in ponyfill ? ponyfill['default'] : ponyfill);\n\n\tvar index$1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _ponyfill = require$$0$1;\n\n\tvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\n\tfunction _interopRequireDefault(obj) {\n\t  return obj && obj.__esModule ? obj : { 'default': obj };\n\t}\n\n\tvar root; /* global window */\n\n\tif (typeof self !== 'undefined') {\n\t  root = self;\n\t} else if (typeof window !== 'undefined') {\n\t  root = window;\n\t} else if (typeof commonjsGlobal !== 'undefined') {\n\t  root = commonjsGlobal;\n\t} else if (typeof module !== 'undefined') {\n\t  root = module;\n\t} else {\n\t  root = Function('return this')();\n\t}\n\n\tvar result = (0, _ponyfill2['default'])(root);\n\texports['default'] = result;\n\t});\n\n\tvar require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);\n\n\tvar index = createCommonjsModule(function (module) {\n\tmodule.exports = require$$0;\n\t});\n\n\tvar $$observable = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n\tfunction fromESObservable(_observable) {\n\t  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;\n\t  return stream(function (emitter) {\n\t    var unsub = observable.subscribe({\n\t      error: function (error) {\n\t        emitter.error(error);\n\t        emitter.end();\n\t      },\n\t      next: function (value) {\n\t        emitter.emit(value);\n\t      },\n\t      complete: function () {\n\t        emitter.end();\n\t      }\n\t    });\n\n\t    if (unsub.unsubscribe) {\n\t      return function () {\n\t        unsub.unsubscribe();\n\t      };\n\t    } else {\n\t      return unsub;\n\t    }\n\t  }).setName('fromESObservable');\n\t}\n\n\tfunction ESObservable(observable) {\n\t  this._observable = observable.takeErrors(1);\n\t}\n\n\textend(ESObservable.prototype, {\n\t  subscribe: function (observerOrOnNext, onError, onComplete) {\n\t    var _this = this;\n\n\t    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;\n\n\t    var fn = function (event) {\n\t      if (event.type === END) {\n\t        closed = true;\n\t      }\n\n\t      if (event.type === VALUE && observer.next) {\n\t        observer.next(event.value);\n\t      } else if (event.type === ERROR && observer.error) {\n\t        observer.error(event.value);\n\t      } else if (event.type === END && observer.complete) {\n\t        observer.complete(event.value);\n\t      }\n\t    };\n\n\t    this._observable.onAny(fn);\n\t    var closed = false;\n\n\t    var subscription = {\n\t      unsubscribe: function () {\n\t        closed = true;\n\t        _this._observable.offAny(fn);\n\t      },\n\t      get closed() {\n\t        return closed;\n\t      }\n\t    };\n\t    return subscription;\n\t  }\n\t});\n\n\t// Need to assign directly b/c Symbols aren't enumerable.\n\tESObservable.prototype[$$observable] = function () {\n\t  return this;\n\t};\n\n\tfunction toESObservable() {\n\t  return new ESObservable(this);\n\t}\n\n\tfunction collect(source, keys, values) {\n\t  for (var prop in source) {\n\t    if (source.hasOwnProperty(prop)) {\n\t      keys.push(prop);\n\t      values.push(source[prop]);\n\t    }\n\t  }\n\t}\n\n\tfunction defaultErrorsCombinator(errors) {\n\t  var latestError = void 0;\n\t  for (var i = 0; i < errors.length; i++) {\n\t    if (errors[i] !== undefined) {\n\t      if (latestError === undefined || latestError.index < errors[i].index) {\n\t        latestError = errors[i];\n\t      }\n\t    }\n\t  }\n\t  return latestError.error;\n\t}\n\n\tfunction Combine(active, passive, combinator) {\n\t  var _this = this;\n\n\t  Stream.call(this);\n\t  this._activeCount = active.length;\n\t  this._sources = concat(active, passive);\n\t  this._combinator = combinator;\n\t  this._aliveCount = 0;\n\t  this._latestValues = new Array(this._sources.length);\n\t  this._latestErrors = new Array(this._sources.length);\n\t  fillArray(this._latestValues, NOTHING);\n\t  this._emitAfterActivation = false;\n\t  this._endAfterActivation = false;\n\t  this._latestErrorIndex = 0;\n\n\t  this._$handlers = [];\n\n\t  var _loop = function (i) {\n\t    _this._$handlers.push(function (event) {\n\t      return _this._handleAny(i, event);\n\t    });\n\t  };\n\n\t  for (var i = 0; i < this._sources.length; i++) {\n\t    _loop(i);\n\t  }\n\t}\n\n\tinherit(Combine, Stream, {\n\n\t  _name: 'combine',\n\n\t  _onActivation: function () {\n\t    this._aliveCount = this._activeCount;\n\n\t    // we need to suscribe to _passive_ sources before _active_\n\t    // (see https://github.com/rpominov/kefir/issues/98)\n\t    for (var i = this._activeCount; i < this._sources.length; i++) {\n\t      this._sources[i].onAny(this._$handlers[i]);\n\t    }\n\t    for (var _i = 0; _i < this._activeCount; _i++) {\n\t      this._sources[_i].onAny(this._$handlers[_i]);\n\t    }\n\n\t    if (this._emitAfterActivation) {\n\t      this._emitAfterActivation = false;\n\t      this._emitIfFull();\n\t    }\n\t    if (this._endAfterActivation) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    var length = this._sources.length,\n\t        i = void 0;\n\t    for (i = 0; i < length; i++) {\n\t      this._sources[i].offAny(this._$handlers[i]);\n\t    }\n\t  },\n\t  _emitIfFull: function () {\n\t    var hasAllValues = true;\n\t    var hasErrors = false;\n\t    var length = this._latestValues.length;\n\t    var valuesCopy = new Array(length);\n\t    var errorsCopy = new Array(length);\n\n\t    for (var i = 0; i < length; i++) {\n\t      valuesCopy[i] = this._latestValues[i];\n\t      errorsCopy[i] = this._latestErrors[i];\n\n\t      if (valuesCopy[i] === NOTHING) {\n\t        hasAllValues = false;\n\t      }\n\n\t      if (errorsCopy[i] !== undefined) {\n\t        hasErrors = true;\n\t      }\n\t    }\n\n\t    if (hasAllValues) {\n\t      var combinator = this._combinator;\n\t      this._emitValue(combinator(valuesCopy));\n\t    }\n\t    if (hasErrors) {\n\t      this._emitError(defaultErrorsCombinator(errorsCopy));\n\t    }\n\t  },\n\t  _handleAny: function (i, event) {\n\n\t    if (event.type === VALUE || event.type === ERROR) {\n\n\t      if (event.type === VALUE) {\n\t        this._latestValues[i] = event.value;\n\t        this._latestErrors[i] = undefined;\n\t      }\n\t      if (event.type === ERROR) {\n\t        this._latestValues[i] = NOTHING;\n\t        this._latestErrors[i] = {\n\t          index: this._latestErrorIndex++,\n\t          error: event.value\n\t        };\n\t      }\n\n\t      if (i < this._activeCount) {\n\t        if (this._activating) {\n\t          this._emitAfterActivation = true;\n\t        } else {\n\t          this._emitIfFull();\n\t        }\n\t      }\n\t    } else {\n\t      // END\n\n\t      if (i < this._activeCount) {\n\t        this._aliveCount--;\n\t        if (this._aliveCount === 0) {\n\t          if (this._activating) {\n\t            this._endAfterActivation = true;\n\t          } else {\n\t            this._emitEnd();\n\t          }\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._sources = null;\n\t    this._latestValues = null;\n\t    this._latestErrors = null;\n\t    this._combinator = null;\n\t    this._$handlers = null;\n\t  }\n\t});\n\n\tfunction combineAsArray(active) {\n\t  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var combinator = arguments[2];\n\n\t  if (!Array.isArray(passive)) {\n\t    throw new Error('Combine can only combine active and passive collections of the same type.');\n\t  }\n\n\t  combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {\n\t    return x;\n\t  };\n\t  return active.length === 0 ? never() : new Combine(active, passive, combinator);\n\t}\n\n\tfunction combineAsObject(active) {\n\t  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t  var combinator = arguments[2];\n\n\t  if (typeof passive !== 'object' || Array.isArray(passive)) {\n\t    throw new Error('Combine can only combine active and passive collections of the same type.');\n\t  }\n\n\t  var keys = [],\n\t      activeObservables = [],\n\t      passiveObservables = [];\n\n\t  collect(active, keys, activeObservables);\n\t  collect(passive, keys, passiveObservables);\n\n\t  var objectify = function (values) {\n\t    var event = {};\n\t    for (var i = values.length - 1; 0 <= i; i--) {\n\t      event[keys[i]] = values[i];\n\t    }\n\t    return combinator ? combinator(event) : event;\n\t  };\n\n\t  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);\n\t}\n\n\tfunction combine(active, passive, combinator) {\n\t  if (typeof passive === 'function') {\n\t    combinator = passive;\n\t    passive = undefined;\n\t  }\n\n\t  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);\n\t}\n\n\tvar Observable$1 = {\n\t  empty: function () {\n\t    return never();\n\t  },\n\n\n\t  // Monoid based on merge() seems more useful than one based on concat().\n\t  concat: function (a, b) {\n\t    return a.merge(b);\n\t  },\n\t  of: function (x) {\n\t    return constant(x);\n\t  },\n\t  map: function (fn, obs) {\n\t    return obs.map(fn);\n\t  },\n\t  bimap: function (fnErr, fnVal, obs) {\n\t    return obs.mapErrors(fnErr).map(fnVal);\n\t  },\n\n\n\t  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get\n\t  // different (not very useful) behavior. But spec requires that if method can be derived\n\t  // it must have the same behavior as hand-written method. We intentionally violate the spec\n\t  // in hope that it won't cause many troubles in practice. And in return we have more useful type.\n\t  ap: function (obsFn, obsVal) {\n\t    return combine([obsFn, obsVal], function (fn, val) {\n\t      return fn(val);\n\t    });\n\t  },\n\t  chain: function (fn, obs) {\n\t    return obs.flatMap(fn);\n\t  }\n\t};\n\n\n\n\tvar staticLand = Object.freeze({\n\t  Observable: Observable$1\n\t});\n\n\tvar mixin = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    this._emitValue(fn(x));\n\t  }\n\t};\n\n\tvar S$7 = createStream('map', mixin);\n\tvar P$3 = createProperty('map', mixin);\n\n\tvar id = function (x) {\n\t  return x;\n\t};\n\n\tfunction map$1(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;\n\n\t  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });\n\t}\n\n\tvar mixin$1 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (fn(x)) {\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$8 = createStream('filter', mixin$1);\n\tvar P$4 = createProperty('filter', mixin$1);\n\n\tvar id$1 = function (x) {\n\t  return x;\n\t};\n\n\tfunction filter(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;\n\n\t  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });\n\t}\n\n\tvar mixin$2 = {\n\t  _init: function (_ref) {\n\t    var n = _ref.n;\n\n\t    this._n = n;\n\t    if (n <= 0) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._n--;\n\t    this._emitValue(x);\n\t    if (this._n === 0) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$9 = createStream('take', mixin$2);\n\tvar P$5 = createProperty('take', mixin$2);\n\n\tfunction take(obs, n) {\n\t  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });\n\t}\n\n\tvar mixin$3 = {\n\t  _init: function (_ref) {\n\t    var n = _ref.n;\n\n\t    this._n = n;\n\t    if (n <= 0) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _handleError: function (x) {\n\t    this._n--;\n\t    this._emitError(x);\n\t    if (this._n === 0) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$10 = createStream('takeErrors', mixin$3);\n\tvar P$6 = createProperty('takeErrors', mixin$3);\n\n\tfunction takeErrors(obs, n) {\n\t  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });\n\t}\n\n\tvar mixin$4 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (fn(x)) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$11 = createStream('takeWhile', mixin$4);\n\tvar P$7 = createProperty('takeWhile', mixin$4);\n\n\tvar id$2 = function (x) {\n\t  return x;\n\t};\n\n\tfunction takeWhile(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;\n\n\t  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });\n\t}\n\n\tvar mixin$5 = {\n\t  _init: function () {\n\t    this._lastValue = NOTHING;\n\t  },\n\t  _free: function () {\n\t    this._lastValue = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    this._lastValue = x;\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._lastValue !== NOTHING) {\n\t      this._emitValue(this._lastValue);\n\t    }\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$12 = createStream('last', mixin$5);\n\tvar P$8 = createProperty('last', mixin$5);\n\n\tfunction last(obs) {\n\t  return new (obs._ofSameType(S$12, P$8))(obs);\n\t}\n\n\tvar mixin$6 = {\n\t  _init: function (_ref) {\n\t    var n = _ref.n;\n\n\t    this._n = Math.max(0, n);\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._n === 0) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._n--;\n\t    }\n\t  }\n\t};\n\n\tvar S$13 = createStream('skip', mixin$6);\n\tvar P$9 = createProperty('skip', mixin$6);\n\n\tfunction skip(obs, n) {\n\t  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });\n\t}\n\n\tvar mixin$7 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (this._fn !== null && !fn(x)) {\n\t      this._fn = null;\n\t    }\n\t    if (this._fn === null) {\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$14 = createStream('skipWhile', mixin$7);\n\tvar P$10 = createProperty('skipWhile', mixin$7);\n\n\tvar id$3 = function (x) {\n\t  return x;\n\t};\n\n\tfunction skipWhile(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;\n\n\t  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });\n\t}\n\n\tvar mixin$8 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t    this._prev = NOTHING;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t    this._prev = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (this._prev === NOTHING || !fn(this._prev, x)) {\n\t      this._prev = x;\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$15 = createStream('skipDuplicates', mixin$8);\n\tvar P$11 = createProperty('skipDuplicates', mixin$8);\n\n\tvar eq = function (a, b) {\n\t  return a === b;\n\t};\n\n\tfunction skipDuplicates(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;\n\n\t  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });\n\t}\n\n\tvar mixin$9 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn,\n\t        seed = _ref.seed;\n\n\t    this._fn = fn;\n\t    this._prev = seed;\n\t  },\n\t  _free: function () {\n\t    this._prev = null;\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._prev !== NOTHING) {\n\t      var fn = this._fn;\n\t      this._emitValue(fn(this._prev, x));\n\t    }\n\t    this._prev = x;\n\t  }\n\t};\n\n\tvar S$16 = createStream('diff', mixin$9);\n\tvar P$12 = createProperty('diff', mixin$9);\n\n\tfunction defaultFn(a, b) {\n\t  return [a, b];\n\t}\n\n\tfunction diff(obs, fn) {\n\t  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n\t  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });\n\t}\n\n\tvar P$13 = createProperty('scan', {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn,\n\t        seed = _ref.seed;\n\n\t    this._fn = fn;\n\t    this._seed = seed;\n\t    if (seed !== NOTHING) {\n\t      this._emitValue(seed);\n\t    }\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t    this._seed = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n\t      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n\t    } else {\n\t      this._emitValue(fn(this._currentEvent.value, x));\n\t    }\n\t  }\n\t});\n\n\tfunction scan(obs, fn) {\n\t  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n\t  return new P$13(obs, { fn: fn, seed: seed });\n\t}\n\n\tvar mixin$10 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    var xs = fn(x);\n\t    for (var i = 0; i < xs.length; i++) {\n\t      this._emitValue(xs[i]);\n\t    }\n\t  }\n\t};\n\n\tvar S$17 = createStream('flatten', mixin$10);\n\n\tvar id$4 = function (x) {\n\t  return x;\n\t};\n\n\tfunction flatten(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;\n\n\t  return new S$17(obs, { fn: fn });\n\t}\n\n\tvar END_MARKER = {};\n\n\tvar mixin$11 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait;\n\n\t    this._wait = Math.max(0, wait);\n\t    this._buff = [];\n\t    this._$shiftBuff = function () {\n\t      var value = _this._buff.shift();\n\t      if (value === END_MARKER) {\n\t        _this._emitEnd();\n\t      } else {\n\t        _this._emitValue(value);\n\t      }\n\t    };\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t    this._$shiftBuff = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._activating) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._buff.push(x);\n\t      setTimeout(this._$shiftBuff, this._wait);\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._activating) {\n\t      this._emitEnd();\n\t    } else {\n\t      this._buff.push(END_MARKER);\n\t      setTimeout(this._$shiftBuff, this._wait);\n\t    }\n\t  }\n\t};\n\n\tvar S$18 = createStream('delay', mixin$11);\n\tvar P$14 = createProperty('delay', mixin$11);\n\n\tfunction delay(obs, wait) {\n\t  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });\n\t}\n\n\tvar now = Date.now ? function () {\n\t  return Date.now();\n\t} : function () {\n\t  return new Date().getTime();\n\t};\n\n\tvar mixin$12 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait,\n\t        leading = _ref.leading,\n\t        trailing = _ref.trailing;\n\n\t    this._wait = Math.max(0, wait);\n\t    this._leading = leading;\n\t    this._trailing = trailing;\n\t    this._trailingValue = null;\n\t    this._timeoutId = null;\n\t    this._endLater = false;\n\t    this._lastCallTime = 0;\n\t    this._$trailingCall = function () {\n\t      return _this._trailingCall();\n\t    };\n\t  },\n\t  _free: function () {\n\t    this._trailingValue = null;\n\t    this._$trailingCall = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._activating) {\n\t      this._emitValue(x);\n\t    } else {\n\t      var curTime = now();\n\t      if (this._lastCallTime === 0 && !this._leading) {\n\t        this._lastCallTime = curTime;\n\t      }\n\t      var remaining = this._wait - (curTime - this._lastCallTime);\n\t      if (remaining <= 0) {\n\t        this._cancelTrailing();\n\t        this._lastCallTime = curTime;\n\t        this._emitValue(x);\n\t      } else if (this._trailing) {\n\t        this._cancelTrailing();\n\t        this._trailingValue = x;\n\t        this._timeoutId = setTimeout(this._$trailingCall, remaining);\n\t      }\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._activating) {\n\t      this._emitEnd();\n\t    } else {\n\t      if (this._timeoutId) {\n\t        this._endLater = true;\n\t      } else {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  },\n\t  _cancelTrailing: function () {\n\t    if (this._timeoutId !== null) {\n\t      clearTimeout(this._timeoutId);\n\t      this._timeoutId = null;\n\t    }\n\t  },\n\t  _trailingCall: function () {\n\t    this._emitValue(this._trailingValue);\n\t    this._timeoutId = null;\n\t    this._trailingValue = null;\n\t    this._lastCallTime = !this._leading ? 0 : now();\n\t    if (this._endLater) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$19 = createStream('throttle', mixin$12);\n\tvar P$15 = createProperty('throttle', mixin$12);\n\n\tfunction throttle(obs, wait) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$leading = _ref2.leading,\n\t      leading = _ref2$leading === undefined ? true : _ref2$leading,\n\t      _ref2$trailing = _ref2.trailing,\n\t      trailing = _ref2$trailing === undefined ? true : _ref2$trailing;\n\n\t  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });\n\t}\n\n\tvar mixin$13 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait,\n\t        immediate = _ref.immediate;\n\n\t    this._wait = Math.max(0, wait);\n\t    this._immediate = immediate;\n\t    this._lastAttempt = 0;\n\t    this._timeoutId = null;\n\t    this._laterValue = null;\n\t    this._endLater = false;\n\t    this._$later = function () {\n\t      return _this._later();\n\t    };\n\t  },\n\t  _free: function () {\n\t    this._laterValue = null;\n\t    this._$later = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._activating) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._lastAttempt = now();\n\t      if (this._immediate && !this._timeoutId) {\n\t        this._emitValue(x);\n\t      }\n\t      if (!this._timeoutId) {\n\t        this._timeoutId = setTimeout(this._$later, this._wait);\n\t      }\n\t      if (!this._immediate) {\n\t        this._laterValue = x;\n\t      }\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._activating) {\n\t      this._emitEnd();\n\t    } else {\n\t      if (this._timeoutId && !this._immediate) {\n\t        this._endLater = true;\n\t      } else {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  },\n\t  _later: function () {\n\t    var last = now() - this._lastAttempt;\n\t    if (last < this._wait && last >= 0) {\n\t      this._timeoutId = setTimeout(this._$later, this._wait - last);\n\t    } else {\n\t      this._timeoutId = null;\n\t      if (!this._immediate) {\n\t        this._emitValue(this._laterValue);\n\t        this._laterValue = null;\n\t      }\n\t      if (this._endLater) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  }\n\t};\n\n\tvar S$20 = createStream('debounce', mixin$13);\n\tvar P$16 = createProperty('debounce', mixin$13);\n\n\tfunction debounce(obs, wait) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$immediate = _ref2.immediate,\n\t      immediate = _ref2$immediate === undefined ? false : _ref2$immediate;\n\n\t  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });\n\t}\n\n\tvar mixin$14 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleError: function (x) {\n\t    var fn = this._fn;\n\t    this._emitError(fn(x));\n\t  }\n\t};\n\n\tvar S$21 = createStream('mapErrors', mixin$14);\n\tvar P$17 = createProperty('mapErrors', mixin$14);\n\n\tvar id$5 = function (x) {\n\t  return x;\n\t};\n\n\tfunction mapErrors(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;\n\n\t  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });\n\t}\n\n\tvar mixin$15 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleError: function (x) {\n\t    var fn = this._fn;\n\t    if (fn(x)) {\n\t      this._emitError(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$22 = createStream('filterErrors', mixin$15);\n\tvar P$18 = createProperty('filterErrors', mixin$15);\n\n\tvar id$6 = function (x) {\n\t  return x;\n\t};\n\n\tfunction filterErrors(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;\n\n\t  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });\n\t}\n\n\tvar mixin$16 = {\n\t  _handleValue: function () {}\n\t};\n\n\tvar S$23 = createStream('ignoreValues', mixin$16);\n\tvar P$19 = createProperty('ignoreValues', mixin$16);\n\n\tfunction ignoreValues(obs) {\n\t  return new (obs._ofSameType(S$23, P$19))(obs);\n\t}\n\n\tvar mixin$17 = {\n\t  _handleError: function () {}\n\t};\n\n\tvar S$24 = createStream('ignoreErrors', mixin$17);\n\tvar P$20 = createProperty('ignoreErrors', mixin$17);\n\n\tfunction ignoreErrors(obs) {\n\t  return new (obs._ofSameType(S$24, P$20))(obs);\n\t}\n\n\tvar mixin$18 = {\n\t  _handleEnd: function () {}\n\t};\n\n\tvar S$25 = createStream('ignoreEnd', mixin$18);\n\tvar P$21 = createProperty('ignoreEnd', mixin$18);\n\n\tfunction ignoreEnd(obs) {\n\t  return new (obs._ofSameType(S$25, P$21))(obs);\n\t}\n\n\tvar mixin$19 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleEnd: function () {\n\t    var fn = this._fn;\n\t    this._emitValue(fn());\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$26 = createStream('beforeEnd', mixin$19);\n\tvar P$22 = createProperty('beforeEnd', mixin$19);\n\n\tfunction beforeEnd(obs, fn) {\n\t  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });\n\t}\n\n\tvar mixin$20 = {\n\t  _init: function (_ref) {\n\t    var min = _ref.min,\n\t        max = _ref.max;\n\n\t    this._max = max;\n\t    this._min = min;\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff = slide(this._buff, x, this._max);\n\t    if (this._buff.length >= this._min) {\n\t      this._emitValue(this._buff);\n\t    }\n\t  }\n\t};\n\n\tvar S$27 = createStream('slidingWindow', mixin$20);\n\tvar P$23 = createProperty('slidingWindow', mixin$20);\n\n\tfunction slidingWindow(obs, max) {\n\t  var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });\n\t}\n\n\tvar mixin$21 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn,\n\t        flushOnEnd = _ref.flushOnEnd;\n\n\t    this._fn = fn;\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null && this._buff.length !== 0) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff.push(x);\n\t    var fn = this._fn;\n\t    if (!fn(x)) {\n\t      this._flush();\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$28 = createStream('bufferWhile', mixin$21);\n\tvar P$24 = createProperty('bufferWhile', mixin$21);\n\n\tvar id$7 = function (x) {\n\t  return x;\n\t};\n\n\tfunction bufferWhile(obs, fn) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$flushOnEnd = _ref2.flushOnEnd,\n\t      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n\t  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });\n\t}\n\n\tvar mixin$22 = {\n\t  _init: function (_ref) {\n\t    var count = _ref.count,\n\t        flushOnEnd = _ref.flushOnEnd;\n\n\t    this._count = count;\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null && this._buff.length !== 0) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff.push(x);\n\t    if (this._buff.length >= this._count) {\n\t      this._flush();\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$29 = createStream('bufferWithCount', mixin$22);\n\tvar P$25 = createProperty('bufferWithCount', mixin$22);\n\n\tfunction bufferWhile$1(obs, count) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$flushOnEnd = _ref2.flushOnEnd,\n\t      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n\t  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });\n\t}\n\n\tvar mixin$23 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait,\n\t        count = _ref.count,\n\t        flushOnEnd = _ref.flushOnEnd;\n\n\t    this._wait = wait;\n\t    this._count = count;\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._intervalId = null;\n\t    this._$onTick = function () {\n\t      return _this._flush();\n\t    };\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._$onTick = null;\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff.push(x);\n\t    if (this._buff.length >= this._count) {\n\t      clearInterval(this._intervalId);\n\t      this._flush();\n\t      this._intervalId = setInterval(this._$onTick, this._wait);\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._flushOnEnd && this._buff.length !== 0) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  },\n\t  _onActivation: function () {\n\t    this._intervalId = setInterval(this._$onTick, this._wait);\n\t    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\t  },\n\t  _onDeactivation: function () {\n\t    if (this._intervalId !== null) {\n\t      clearInterval(this._intervalId);\n\t      this._intervalId = null;\n\t    }\n\t    this._source.offAny(this._$handleAny); // copied from patterns/one-source\n\t  }\n\t};\n\n\tvar S$30 = createStream('bufferWithTimeOrCount', mixin$23);\n\tvar P$26 = createProperty('bufferWithTimeOrCount', mixin$23);\n\n\tfunction bufferWithTimeOrCount(obs, wait, count) {\n\t  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n\t      _ref2$flushOnEnd = _ref2.flushOnEnd,\n\t      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n\t  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });\n\t}\n\n\tfunction xformForObs(obs) {\n\t  return {\n\t    '@@transducer/step': function (res, input) {\n\t      obs._emitValue(input);\n\t      return null;\n\t    },\n\t    '@@transducer/result': function () {\n\t      obs._emitEnd();\n\t      return null;\n\t    }\n\t  };\n\t}\n\n\tvar mixin$24 = {\n\t  _init: function (_ref) {\n\t    var transducer = _ref.transducer;\n\n\t    this._xform = transducer(xformForObs(this));\n\t  },\n\t  _free: function () {\n\t    this._xform = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._xform['@@transducer/step'](null, x) !== null) {\n\t      this._xform['@@transducer/result'](null);\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    this._xform['@@transducer/result'](null);\n\t  }\n\t};\n\n\tvar S$31 = createStream('transduce', mixin$24);\n\tvar P$27 = createProperty('transduce', mixin$24);\n\n\tfunction transduce(obs, transducer) {\n\t  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });\n\t}\n\n\tvar mixin$25 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._handler = fn;\n\t    this._emitter = emitter(this);\n\t  },\n\t  _free: function () {\n\t    this._handler = null;\n\t    this._emitter = null;\n\t  },\n\t  _handleAny: function (event) {\n\t    this._handler(this._emitter, event);\n\t  }\n\t};\n\n\tvar S$32 = createStream('withHandler', mixin$25);\n\tvar P$28 = createProperty('withHandler', mixin$25);\n\n\tfunction withHandler(obs, fn) {\n\t  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });\n\t}\n\n\tvar isArray = Array.isArray || function (xs) {\n\t  return Object.prototype.toString.call(xs) === '[object Array]';\n\t};\n\n\tfunction Zip(sources, combinator) {\n\t  var _this = this;\n\n\t  Stream.call(this);\n\n\t  this._buffers = map(sources, function (source) {\n\t    return isArray(source) ? cloneArray(source) : [];\n\t  });\n\t  this._sources = map(sources, function (source) {\n\t    return isArray(source) ? never() : source;\n\t  });\n\n\t  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n\t    return x;\n\t  };\n\t  this._aliveCount = 0;\n\n\t  this._$handlers = [];\n\n\t  var _loop = function (i) {\n\t    _this._$handlers.push(function (event) {\n\t      return _this._handleAny(i, event);\n\t    });\n\t  };\n\n\t  for (var i = 0; i < this._sources.length; i++) {\n\t    _loop(i);\n\t  }\n\t}\n\n\tinherit(Zip, Stream, {\n\n\t  _name: 'zip',\n\n\t  _onActivation: function () {\n\n\t    // if all sources are arrays\n\t    while (this._isFull()) {\n\t      this._emit();\n\t    }\n\n\t    var length = this._sources.length;\n\t    this._aliveCount = length;\n\t    for (var i = 0; i < length && this._active; i++) {\n\t      this._sources[i].onAny(this._$handlers[i]);\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    for (var i = 0; i < this._sources.length; i++) {\n\t      this._sources[i].offAny(this._$handlers[i]);\n\t    }\n\t  },\n\t  _emit: function () {\n\t    var values = new Array(this._buffers.length);\n\t    for (var i = 0; i < this._buffers.length; i++) {\n\t      values[i] = this._buffers[i].shift();\n\t    }\n\t    var combinator = this._combinator;\n\t    this._emitValue(combinator(values));\n\t  },\n\t  _isFull: function () {\n\t    for (var i = 0; i < this._buffers.length; i++) {\n\t      if (this._buffers[i].length === 0) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  },\n\t  _handleAny: function (i, event) {\n\t    if (event.type === VALUE) {\n\t      this._buffers[i].push(event.value);\n\t      if (this._isFull()) {\n\t        this._emit();\n\t      }\n\t    }\n\t    if (event.type === ERROR) {\n\t      this._emitError(event.value);\n\t    }\n\t    if (event.type === END) {\n\t      this._aliveCount--;\n\t      if (this._aliveCount === 0) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._sources = null;\n\t    this._buffers = null;\n\t    this._combinator = null;\n\t    this._$handlers = null;\n\t  }\n\t});\n\n\tfunction zip(observables, combinator /* Function | falsey */) {\n\t  return observables.length === 0 ? never() : new Zip(observables, combinator);\n\t}\n\n\tvar id$8 = function (x) {\n\t  return x;\n\t};\n\n\tfunction AbstractPool() {\n\t  var _this = this;\n\n\t  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t      _ref$queueLim = _ref.queueLim,\n\t      queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,\n\t      _ref$concurLim = _ref.concurLim,\n\t      concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,\n\t      _ref$drop = _ref.drop,\n\t      drop = _ref$drop === undefined ? 'new' : _ref$drop;\n\n\t  Stream.call(this);\n\n\t  this._queueLim = queueLim < 0 ? -1 : queueLim;\n\t  this._concurLim = concurLim < 0 ? -1 : concurLim;\n\t  this._drop = drop;\n\t  this._queue = [];\n\t  this._curSources = [];\n\t  this._$handleSubAny = function (event) {\n\t    return _this._handleSubAny(event);\n\t  };\n\t  this._$endHandlers = [];\n\t  this._currentlyAdding = null;\n\n\t  if (this._concurLim === 0) {\n\t    this._emitEnd();\n\t  }\n\t}\n\n\tinherit(AbstractPool, Stream, {\n\n\t  _name: 'abstractPool',\n\n\t  _add: function (obj, toObs /* Function | falsey */) {\n\t    toObs = toObs || id$8;\n\t    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n\t      this._addToCur(toObs(obj));\n\t    } else {\n\t      if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n\t        this._addToQueue(toObs(obj));\n\t      } else if (this._drop === 'old') {\n\t        this._removeOldest();\n\t        this._add(obj, toObs);\n\t      }\n\t    }\n\t  },\n\t  _addAll: function (obss) {\n\t    var _this2 = this;\n\n\t    forEach(obss, function (obs) {\n\t      return _this2._add(obs);\n\t    });\n\t  },\n\t  _remove: function (obs) {\n\t    if (this._removeCur(obs) === -1) {\n\t      this._removeQueue(obs);\n\t    }\n\t  },\n\t  _addToQueue: function (obs) {\n\t    this._queue = concat(this._queue, [obs]);\n\t  },\n\t  _addToCur: function (obs) {\n\t    if (this._active) {\n\n\t      // HACK:\n\t      //\n\t      // We have two optimizations for cases when `obs` is ended. We don't want\n\t      // to add such observable to the list, but only want to emit events\n\t      // from it (if it has some).\n\t      //\n\t      // Instead of this hacks, we could just did following,\n\t      // but it would be 5-8 times slower:\n\t      //\n\t      //     this._curSources = concat(this._curSources, [obs]);\n\t      //     this._subscribe(obs);\n\t      //\n\n\t      // #1\n\t      // This one for cases when `obs` already ended\n\t      // e.g., Kefir.constant() or Kefir.never()\n\t      if (!obs._alive) {\n\t        if (obs._currentEvent) {\n\t          this._emit(obs._currentEvent.type, obs._currentEvent.value);\n\t        }\n\t        return;\n\t      }\n\n\t      // #2\n\t      // This one is for cases when `obs` going to end synchronously on\n\t      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n\t      this._currentlyAdding = obs;\n\t      obs.onAny(this._$handleSubAny);\n\t      this._currentlyAdding = null;\n\t      if (obs._alive) {\n\t        this._curSources = concat(this._curSources, [obs]);\n\t        if (this._active) {\n\t          this._subToEnd(obs);\n\t        }\n\t      }\n\t    } else {\n\t      this._curSources = concat(this._curSources, [obs]);\n\t    }\n\t  },\n\t  _subToEnd: function (obs) {\n\t    var _this3 = this;\n\n\t    var onEnd = function () {\n\t      return _this3._removeCur(obs);\n\t    };\n\t    this._$endHandlers.push({ obs: obs, handler: onEnd });\n\t    obs.onEnd(onEnd);\n\t  },\n\t  _subscribe: function (obs) {\n\t    obs.onAny(this._$handleSubAny);\n\n\t    // it can become inactive in responce of subscribing to `obs.onAny` above\n\t    if (this._active) {\n\t      this._subToEnd(obs);\n\t    }\n\t  },\n\t  _unsubscribe: function (obs) {\n\t    obs.offAny(this._$handleSubAny);\n\n\t    var onEndI = findByPred(this._$endHandlers, function (obj) {\n\t      return obj.obs === obs;\n\t    });\n\t    if (onEndI !== -1) {\n\t      obs.offEnd(this._$endHandlers[onEndI].handler);\n\t      this._$endHandlers.splice(onEndI, 1);\n\t    }\n\t  },\n\t  _handleSubAny: function (event) {\n\t    if (event.type === VALUE) {\n\t      this._emitValue(event.value);\n\t    } else if (event.type === ERROR) {\n\t      this._emitError(event.value);\n\t    }\n\t  },\n\t  _removeQueue: function (obs) {\n\t    var index = find(this._queue, obs);\n\t    this._queue = remove(this._queue, index);\n\t    return index;\n\t  },\n\t  _removeCur: function (obs) {\n\t    if (this._active) {\n\t      this._unsubscribe(obs);\n\t    }\n\t    var index = find(this._curSources, obs);\n\t    this._curSources = remove(this._curSources, index);\n\t    if (index !== -1) {\n\t      if (this._queue.length !== 0) {\n\t        this._pullQueue();\n\t      } else if (this._curSources.length === 0) {\n\t        this._onEmpty();\n\t      }\n\t    }\n\t    return index;\n\t  },\n\t  _removeOldest: function () {\n\t    this._removeCur(this._curSources[0]);\n\t  },\n\t  _pullQueue: function () {\n\t    if (this._queue.length !== 0) {\n\t      this._queue = cloneArray(this._queue);\n\t      this._addToCur(this._queue.shift());\n\t    }\n\t  },\n\t  _onActivation: function () {\n\t    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n\t      this._subscribe(sources[i]);\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    for (var i = 0, sources = this._curSources; i < sources.length; i++) {\n\t      this._unsubscribe(sources[i]);\n\t    }\n\t    if (this._currentlyAdding !== null) {\n\t      this._unsubscribe(this._currentlyAdding);\n\t    }\n\t  },\n\t  _isEmpty: function () {\n\t    return this._curSources.length === 0;\n\t  },\n\t  _onEmpty: function () {},\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._queue = null;\n\t    this._curSources = null;\n\t    this._$handleSubAny = null;\n\t    this._$endHandlers = null;\n\t  }\n\t});\n\n\tfunction Merge(sources) {\n\t  AbstractPool.call(this);\n\t  this._addAll(sources);\n\t  this._initialised = true;\n\t}\n\n\tinherit(Merge, AbstractPool, {\n\n\t  _name: 'merge',\n\n\t  _onEmpty: function () {\n\t    if (this._initialised) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t});\n\n\tfunction merge(observables) {\n\t  return observables.length === 0 ? never() : new Merge(observables);\n\t}\n\n\tfunction S$33(generator) {\n\t  var _this = this;\n\n\t  Stream.call(this);\n\t  this._generator = generator;\n\t  this._source = null;\n\t  this._inLoop = false;\n\t  this._iteration = 0;\n\t  this._$handleAny = function (event) {\n\t    return _this._handleAny(event);\n\t  };\n\t}\n\n\tinherit(S$33, Stream, {\n\n\t  _name: 'repeat',\n\n\t  _handleAny: function (event) {\n\t    if (event.type === END) {\n\t      this._source = null;\n\t      this._getSource();\n\t    } else {\n\t      this._emit(event.type, event.value);\n\t    }\n\t  },\n\t  _getSource: function () {\n\t    if (!this._inLoop) {\n\t      this._inLoop = true;\n\t      var generator = this._generator;\n\t      while (this._source === null && this._alive && this._active) {\n\t        this._source = generator(this._iteration++);\n\t        if (this._source) {\n\t          this._source.onAny(this._$handleAny);\n\t        } else {\n\t          this._emitEnd();\n\t        }\n\t      }\n\t      this._inLoop = false;\n\t    }\n\t  },\n\t  _onActivation: function () {\n\t    if (this._source) {\n\t      this._source.onAny(this._$handleAny);\n\t    } else {\n\t      this._getSource();\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    if (this._source) {\n\t      this._source.offAny(this._$handleAny);\n\t    }\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._generator = null;\n\t    this._source = null;\n\t    this._$handleAny = null;\n\t  }\n\t});\n\n\tfunction repeat (generator) {\n\t  return new S$33(generator);\n\t}\n\n\tfunction concat$1(observables) {\n\t  return repeat(function (index) {\n\t    return observables.length > index ? observables[index] : false;\n\t  }).setName('concat');\n\t}\n\n\tfunction Pool() {\n\t  AbstractPool.call(this);\n\t}\n\n\tinherit(Pool, AbstractPool, {\n\n\t  _name: 'pool',\n\n\t  plug: function (obs) {\n\t    this._add(obs);\n\t    return this;\n\t  },\n\t  unplug: function (obs) {\n\t    this._remove(obs);\n\t    return this;\n\t  }\n\t});\n\n\tfunction FlatMap(source, fn, options) {\n\t  var _this = this;\n\n\t  AbstractPool.call(this, options);\n\t  this._source = source;\n\t  this._fn = fn;\n\t  this._mainEnded = false;\n\t  this._lastCurrent = null;\n\t  this._$handleMain = function (event) {\n\t    return _this._handleMain(event);\n\t  };\n\t}\n\n\tinherit(FlatMap, AbstractPool, {\n\t  _onActivation: function () {\n\t    AbstractPool.prototype._onActivation.call(this);\n\t    if (this._active) {\n\t      this._source.onAny(this._$handleMain);\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    AbstractPool.prototype._onDeactivation.call(this);\n\t    this._source.offAny(this._$handleMain);\n\t    this._hadNoEvSinceDeact = true;\n\t  },\n\t  _handleMain: function (event) {\n\n\t    if (event.type === VALUE) {\n\t      // Is latest value before deactivation survived, and now is 'current' on this activation?\n\t      // We don't want to handle such values, to prevent to constantly add\n\t      // same observale on each activation/deactivation when our main source\n\t      // is a `Kefir.conatant()` for example.\n\t      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\t      if (!sameCurr) {\n\t        this._add(event.value, this._fn);\n\t      }\n\t      this._lastCurrent = event.value;\n\t      this._hadNoEvSinceDeact = false;\n\t    }\n\n\t    if (event.type === ERROR) {\n\t      this._emitError(event.value);\n\t    }\n\n\t    if (event.type === END) {\n\t      if (this._isEmpty()) {\n\t        this._emitEnd();\n\t      } else {\n\t        this._mainEnded = true;\n\t      }\n\t    }\n\t  },\n\t  _onEmpty: function () {\n\t    if (this._mainEnded) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _clear: function () {\n\t    AbstractPool.prototype._clear.call(this);\n\t    this._source = null;\n\t    this._lastCurrent = null;\n\t    this._$handleMain = null;\n\t  }\n\t});\n\n\tfunction FlatMapErrors(source, fn) {\n\t  FlatMap.call(this, source, fn);\n\t}\n\n\tinherit(FlatMapErrors, FlatMap, {\n\n\t  // Same as in FlatMap, only VALUE/ERROR flipped\n\t  _handleMain: function (event) {\n\n\t    if (event.type === ERROR) {\n\t      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\t      if (!sameCurr) {\n\t        this._add(event.value, this._fn);\n\t      }\n\t      this._lastCurrent = event.value;\n\t      this._hadNoEvSinceDeact = false;\n\t    }\n\n\t    if (event.type === VALUE) {\n\t      this._emitValue(event.value);\n\t    }\n\n\t    if (event.type === END) {\n\t      if (this._isEmpty()) {\n\t        this._emitEnd();\n\t      } else {\n\t        this._mainEnded = true;\n\t      }\n\t    }\n\t  }\n\t});\n\n\tfunction createConstructor$1(BaseClass, name) {\n\t  return function AnonymousObservable(primary, secondary, options) {\n\t    var _this = this;\n\n\t    BaseClass.call(this);\n\t    this._primary = primary;\n\t    this._secondary = secondary;\n\t    this._name = primary._name + '.' + name;\n\t    this._lastSecondary = NOTHING;\n\t    this._$handleSecondaryAny = function (event) {\n\t      return _this._handleSecondaryAny(event);\n\t    };\n\t    this._$handlePrimaryAny = function (event) {\n\t      return _this._handlePrimaryAny(event);\n\t    };\n\t    this._init(options);\n\t  };\n\t}\n\n\tfunction createClassMethods$1(BaseClass) {\n\t  return {\n\t    _init: function () {},\n\t    _free: function () {},\n\t    _handlePrimaryValue: function (x) {\n\t      this._emitValue(x);\n\t    },\n\t    _handlePrimaryError: function (x) {\n\t      this._emitError(x);\n\t    },\n\t    _handlePrimaryEnd: function () {\n\t      this._emitEnd();\n\t    },\n\t    _handleSecondaryValue: function (x) {\n\t      this._lastSecondary = x;\n\t    },\n\t    _handleSecondaryError: function (x) {\n\t      this._emitError(x);\n\t    },\n\t    _handleSecondaryEnd: function () {},\n\t    _handlePrimaryAny: function (event) {\n\t      switch (event.type) {\n\t        case VALUE:\n\t          return this._handlePrimaryValue(event.value);\n\t        case ERROR:\n\t          return this._handlePrimaryError(event.value);\n\t        case END:\n\t          return this._handlePrimaryEnd(event.value);\n\t      }\n\t    },\n\t    _handleSecondaryAny: function (event) {\n\t      switch (event.type) {\n\t        case VALUE:\n\t          return this._handleSecondaryValue(event.value);\n\t        case ERROR:\n\t          return this._handleSecondaryError(event.value);\n\t        case END:\n\t          this._handleSecondaryEnd(event.value);\n\t          this._removeSecondary();\n\t      }\n\t    },\n\t    _removeSecondary: function () {\n\t      if (this._secondary !== null) {\n\t        this._secondary.offAny(this._$handleSecondaryAny);\n\t        this._$handleSecondaryAny = null;\n\t        this._secondary = null;\n\t      }\n\t    },\n\t    _onActivation: function () {\n\t      if (this._secondary !== null) {\n\t        this._secondary.onAny(this._$handleSecondaryAny);\n\t      }\n\t      if (this._active) {\n\t        this._primary.onAny(this._$handlePrimaryAny);\n\t      }\n\t    },\n\t    _onDeactivation: function () {\n\t      if (this._secondary !== null) {\n\t        this._secondary.offAny(this._$handleSecondaryAny);\n\t      }\n\t      this._primary.offAny(this._$handlePrimaryAny);\n\t    },\n\t    _clear: function () {\n\t      BaseClass.prototype._clear.call(this);\n\t      this._primary = null;\n\t      this._secondary = null;\n\t      this._lastSecondary = null;\n\t      this._$handleSecondaryAny = null;\n\t      this._$handlePrimaryAny = null;\n\t      this._free();\n\t    }\n\t  };\n\t}\n\n\tfunction createStream$1(name, mixin) {\n\t  var S = createConstructor$1(Stream, name);\n\t  inherit(S, Stream, createClassMethods$1(Stream), mixin);\n\t  return S;\n\t}\n\n\tfunction createProperty$1(name, mixin) {\n\t  var P = createConstructor$1(Property, name);\n\t  inherit(P, Property, createClassMethods$1(Property), mixin);\n\t  return P;\n\t}\n\n\tvar mixin$26 = {\n\t  _handlePrimaryValue: function (x) {\n\t    if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n\t      this._emitValue(x);\n\t    }\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$34 = createStream$1('filterBy', mixin$26);\n\tvar P$29 = createProperty$1('filterBy', mixin$26);\n\n\tfunction filterBy(primary, secondary) {\n\t  return new (primary._ofSameType(S$34, P$29))(primary, secondary);\n\t}\n\n\tvar id2 = function (_, x) {\n\t  return x;\n\t};\n\n\tfunction sampledBy(passive, active, combinator) {\n\t  var _combinator = combinator ? function (a, b) {\n\t    return combinator(b, a);\n\t  } : id2;\n\t  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n\t}\n\n\tvar mixin$27 = {\n\t  _handlePrimaryValue: function (x) {\n\t    if (this._lastSecondary !== NOTHING) {\n\t      this._emitValue(x);\n\t    }\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (this._lastSecondary === NOTHING) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$35 = createStream$1('skipUntilBy', mixin$27);\n\tvar P$30 = createProperty$1('skipUntilBy', mixin$27);\n\n\tfunction skipUntilBy(primary, secondary) {\n\t  return new (primary._ofSameType(S$35, P$30))(primary, secondary);\n\t}\n\n\tvar mixin$28 = {\n\t  _handleSecondaryValue: function () {\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$36 = createStream$1('takeUntilBy', mixin$28);\n\tvar P$31 = createProperty$1('takeUntilBy', mixin$28);\n\n\tfunction takeUntilBy(primary, secondary) {\n\t  return new (primary._ofSameType(S$36, P$31))(primary, secondary);\n\t}\n\n\tvar mixin$29 = {\n\t  _init: function () {\n\t    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t        _ref$flushOnEnd = _ref.flushOnEnd,\n\t        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\n\t    this._buff = [];\n\t    this._flushOnEnd = flushOnEnd;\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handlePrimaryEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  },\n\t  _onActivation: function () {\n\t    this._primary.onAny(this._$handlePrimaryAny);\n\t    if (this._alive && this._secondary !== null) {\n\t      this._secondary.onAny(this._$handleSecondaryAny);\n\t    }\n\t  },\n\t  _handlePrimaryValue: function (x) {\n\t    this._buff.push(x);\n\t  },\n\t  _handleSecondaryValue: function () {\n\t    this._flush();\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (!this._flushOnEnd) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$37 = createStream$1('bufferBy', mixin$29);\n\tvar P$32 = createProperty$1('bufferBy', mixin$29);\n\n\tfunction bufferBy(primary, secondary, options /* optional */) {\n\t  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);\n\t}\n\n\tvar mixin$30 = {\n\t  _init: function () {\n\t    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t        _ref$flushOnEnd = _ref.flushOnEnd,\n\t        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,\n\t        _ref$flushOnChange = _ref.flushOnChange,\n\t        flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;\n\n\t    this._buff = [];\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._flushOnChange = flushOnChange;\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handlePrimaryEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  },\n\t  _handlePrimaryValue: function (x) {\n\t    this._buff.push(x);\n\t    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n\t      this._flush();\n\t    }\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _handleSecondaryValue: function (x) {\n\t    if (this._flushOnChange && !x) {\n\t      this._flush();\n\t    }\n\n\t    // from default _handleSecondaryValue\n\t    this._lastSecondary = x;\n\t  }\n\t};\n\n\tvar S$38 = createStream$1('bufferWhileBy', mixin$30);\n\tvar P$33 = createProperty$1('bufferWhileBy', mixin$30);\n\n\tfunction bufferWhileBy(primary, secondary, options /* optional */) {\n\t  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);\n\t}\n\n\tvar f = function () {\n\t  return false;\n\t};\n\tvar t = function () {\n\t  return true;\n\t};\n\n\tfunction awaiting(a, b) {\n\t  var result = merge([map$1(a, t), map$1(b, f)]);\n\t  result = skipDuplicates(result);\n\t  result = toProperty(result, f);\n\t  return result.setName(a, 'awaiting');\n\t}\n\n\tvar mixin$31 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    var result = fn(x);\n\t    if (result.convert) {\n\t      this._emitError(result.error);\n\t    } else {\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$39 = createStream('valuesToErrors', mixin$31);\n\tvar P$34 = createProperty('valuesToErrors', mixin$31);\n\n\tvar defFn = function (x) {\n\t  return { convert: true, error: x };\n\t};\n\n\tfunction valuesToErrors(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;\n\n\t  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });\n\t}\n\n\tvar mixin$32 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleError: function (x) {\n\t    var fn = this._fn;\n\t    var result = fn(x);\n\t    if (result.convert) {\n\t      this._emitValue(result.value);\n\t    } else {\n\t      this._emitError(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$40 = createStream('errorsToValues', mixin$32);\n\tvar P$35 = createProperty('errorsToValues', mixin$32);\n\n\tvar defFn$1 = function (x) {\n\t  return { convert: true, value: x };\n\t};\n\n\tfunction errorsToValues(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;\n\n\t  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });\n\t}\n\n\tvar mixin$33 = {\n\t  _handleError: function (x) {\n\t    this._emitError(x);\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$41 = createStream('endOnError', mixin$33);\n\tvar P$36 = createProperty('endOnError', mixin$33);\n\n\tfunction endOnError(obs) {\n\t  return new (obs._ofSameType(S$41, P$36))(obs);\n\t}\n\n\tObservable.prototype.toProperty = function (fn) {\n\t  return toProperty(this, fn);\n\t};\n\n\tObservable.prototype.changes = function () {\n\t  return changes(this);\n\t};\n\n\tObservable.prototype.toPromise = function (Promise) {\n\t  return toPromise(this, Promise);\n\t};\n\n\tObservable.prototype.toESObservable = toESObservable;\n\tObservable.prototype[$$observable] = toESObservable;\n\n\tObservable.prototype.map = function (fn) {\n\t  return map$1(this, fn);\n\t};\n\n\tObservable.prototype.filter = function (fn) {\n\t  return filter(this, fn);\n\t};\n\n\tObservable.prototype.take = function (n) {\n\t  return take(this, n);\n\t};\n\n\tObservable.prototype.takeErrors = function (n) {\n\t  return takeErrors(this, n);\n\t};\n\n\tObservable.prototype.takeWhile = function (fn) {\n\t  return takeWhile(this, fn);\n\t};\n\n\tObservable.prototype.last = function () {\n\t  return last(this);\n\t};\n\n\tObservable.prototype.skip = function (n) {\n\t  return skip(this, n);\n\t};\n\n\tObservable.prototype.skipWhile = function (fn) {\n\t  return skipWhile(this, fn);\n\t};\n\n\tObservable.prototype.skipDuplicates = function (fn) {\n\t  return skipDuplicates(this, fn);\n\t};\n\n\tObservable.prototype.diff = function (fn, seed) {\n\t  return diff(this, fn, seed);\n\t};\n\n\tObservable.prototype.scan = function (fn, seed) {\n\t  return scan(this, fn, seed);\n\t};\n\n\tObservable.prototype.flatten = function (fn) {\n\t  return flatten(this, fn);\n\t};\n\n\tObservable.prototype.delay = function (wait) {\n\t  return delay(this, wait);\n\t};\n\n\tObservable.prototype.throttle = function (wait, options) {\n\t  return throttle(this, wait, options);\n\t};\n\n\tObservable.prototype.debounce = function (wait, options) {\n\t  return debounce(this, wait, options);\n\t};\n\n\tObservable.prototype.mapErrors = function (fn) {\n\t  return mapErrors(this, fn);\n\t};\n\n\tObservable.prototype.filterErrors = function (fn) {\n\t  return filterErrors(this, fn);\n\t};\n\n\tObservable.prototype.ignoreValues = function () {\n\t  return ignoreValues(this);\n\t};\n\n\tObservable.prototype.ignoreErrors = function () {\n\t  return ignoreErrors(this);\n\t};\n\n\tObservable.prototype.ignoreEnd = function () {\n\t  return ignoreEnd(this);\n\t};\n\n\tObservable.prototype.beforeEnd = function (fn) {\n\t  return beforeEnd(this, fn);\n\t};\n\n\tObservable.prototype.slidingWindow = function (max, min) {\n\t  return slidingWindow(this, max, min);\n\t};\n\n\tObservable.prototype.bufferWhile = function (fn, options) {\n\t  return bufferWhile(this, fn, options);\n\t};\n\n\tObservable.prototype.bufferWithCount = function (count, options) {\n\t  return bufferWhile$1(this, count, options);\n\t};\n\n\tObservable.prototype.bufferWithTimeOrCount = function (wait, count, options) {\n\t  return bufferWithTimeOrCount(this, wait, count, options);\n\t};\n\n\tObservable.prototype.transduce = function (transducer) {\n\t  return transduce(this, transducer);\n\t};\n\n\tObservable.prototype.withHandler = function (fn) {\n\t  return withHandler(this, fn);\n\t};\n\n\tObservable.prototype.combine = function (other, combinator) {\n\t  return combine([this, other], combinator);\n\t};\n\n\tObservable.prototype.zip = function (other, combinator) {\n\t  return zip([this, other], combinator);\n\t};\n\n\tObservable.prototype.merge = function (other) {\n\t  return merge([this, other]);\n\t};\n\n\tObservable.prototype.concat = function (other) {\n\t  return concat$1([this, other]);\n\t};\n\n\tvar pool = function () {\n\t  return new Pool();\n\t};\n\n\tObservable.prototype.flatMap = function (fn) {\n\t  return new FlatMap(this, fn).setName(this, 'flatMap');\n\t};\n\tObservable.prototype.flatMapLatest = function (fn) {\n\t  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');\n\t};\n\tObservable.prototype.flatMapFirst = function (fn) {\n\t  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');\n\t};\n\tObservable.prototype.flatMapConcat = function (fn) {\n\t  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');\n\t};\n\tObservable.prototype.flatMapConcurLimit = function (fn, limit) {\n\t  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');\n\t};\n\n\tObservable.prototype.flatMapErrors = function (fn) {\n\t  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n\t};\n\n\tObservable.prototype.filterBy = function (other) {\n\t  return filterBy(this, other);\n\t};\n\n\tObservable.prototype.sampledBy = function (other, combinator) {\n\t  return sampledBy(this, other, combinator);\n\t};\n\n\tObservable.prototype.skipUntilBy = function (other) {\n\t  return skipUntilBy(this, other);\n\t};\n\n\tObservable.prototype.takeUntilBy = function (other) {\n\t  return takeUntilBy(this, other);\n\t};\n\n\tObservable.prototype.bufferBy = function (other, options) {\n\t  return bufferBy(this, other, options);\n\t};\n\n\tObservable.prototype.bufferWhileBy = function (other, options) {\n\t  return bufferWhileBy(this, other, options);\n\t};\n\n\t// Deprecated\n\t// -----------------------------------------------------------------------------\n\n\tvar DEPRECATION_WARNINGS = true;\n\tfunction dissableDeprecationWarnings() {\n\t  DEPRECATION_WARNINGS = false;\n\t}\n\n\tfunction warn(msg) {\n\t  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {\n\t    var msg2 = '\\nHere is an Error object for you containing the call stack:';\n\t    console.warn(msg, msg2, new Error());\n\t  }\n\t}\n\n\tObservable.prototype.awaiting = function (other) {\n\t  warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');\n\t  return awaiting(this, other);\n\t};\n\n\tObservable.prototype.valuesToErrors = function (fn) {\n\t  warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');\n\t  return valuesToErrors(this, fn);\n\t};\n\n\tObservable.prototype.errorsToValues = function (fn) {\n\t  warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');\n\t  return errorsToValues(this, fn);\n\t};\n\n\tObservable.prototype.endOnError = function () {\n\t  warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');\n\t  return endOnError(this);\n\t};\n\n\t// Exports\n\t// --------------------------------------------------------------------------\n\n\tvar Kefir = { Observable: Observable, Stream: Stream, Property: Property, never: never, later: later, interval: interval, sequentially: sequentially,\n\t  fromPoll: fromPoll, withInterval: withInterval, fromCallback: fromCallback, fromNodeCallback: fromNodeCallback, fromEvents: fromEvents, stream: stream,\n\t  constant: constant, constantError: constantError, fromPromise: fromPromise, fromESObservable: fromESObservable, combine: combine, zip: zip, merge: merge,\n\t  concat: concat$1, Pool: Pool, pool: pool, repeat: repeat, staticLand: staticLand };\n\n\tKefir.Kefir = Kefir;\n\n\texports.dissableDeprecationWarnings = dissableDeprecationWarnings;\n\texports.Kefir = Kefir;\n\texports.Observable = Observable;\n\texports.Stream = Stream;\n\texports.Property = Property;\n\texports.never = never;\n\texports.later = later;\n\texports.interval = interval;\n\texports.sequentially = sequentially;\n\texports.fromPoll = fromPoll;\n\texports.withInterval = withInterval;\n\texports.fromCallback = fromCallback;\n\texports.fromNodeCallback = fromNodeCallback;\n\texports.fromEvents = fromEvents;\n\texports.stream = stream;\n\texports.constant = constant;\n\texports.constantError = constantError;\n\texports.fromPromise = fromPromise;\n\texports.fromESObservable = fromESObservable;\n\texports.combine = combine;\n\texports.zip = zip;\n\texports.merge = merge;\n\texports.concat = concat$1;\n\texports.Pool = Pool;\n\texports.pool = pool;\n\texports.repeat = repeat;\n\texports.staticLand = staticLand;\n\texports['default'] = Kefir;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/release.js":"var inquirer = require('inquirer');\nvar semver = require('semver');\nvar shell = require('shelljs');\nvar fs = require('fs');\n\nvar pkg = require('./package.json');\nvar bower = require('./bower.json');\n\nconsole.log(\"\");\nconsole.log(\"Wellcome to Kefir release utility!\");\nconsole.log(\"----------------------------------------------------------------\");\nconsole.log(\"\");\n\nvar questions = [\n  {\n    type: \"list\",\n    name: \"version\",\n    message: \"Which version will it be? (current is \" + pkg.version + \")\",\n    choices: [\n      semver.inc(pkg.version, 'patch'),\n      semver.inc(pkg.version, 'minor'),\n      semver.inc(pkg.version, 'major'),\n      semver.inc(pkg.version, 'premajor', 'rc')\n    ]\n  },\n  {\n    type: \"list\",\n    name: \"dryRun\",\n    message: \"Do you want to release, or just see what would happen if you do?\",\n    choices: [\n      'Just see',\n      'Release!'\n    ]\n  }\n];\n\ninquirer.prompt(questions, function(answers) {\n  var newVerison = answers.version;\n  var dryRun = (answers.dryRun === 'Just see');\n\n  bower.version = pkg.version = newVerison;\n\n  console.log('');\n  if (dryRun) {\n    console.log('Ok, here is what would happen:');\n  } else {\n    console.log('Doing actual release:');\n  }\n  console.log('');\n\n  run('npm test', dryRun) &&\n  bumpVersion('package.json', pkg, dryRun) &&\n  bumpVersion('bower.json', bower, dryRun) &&\n  run('`npm bin`/grunt', dryRun) &&\n  run('`npm bin`/grunt bower', dryRun) &&\n  run('git add .', dryRun) &&\n  run('git add -f dist', dryRun) &&\n  run('git add -f index.html', dryRun) &&\n  run('git add -f bower-packages', dryRun) &&\n  run('git add -f test/in-browser/spec/KefirSpecs.js', dryRun) &&\n  run('git commit -m \"' + newVerison + '\"', dryRun) &&\n  run('git push', dryRun) &&\n  run('git tag -a ' + newVerison + ' -m \"v' + newVerison + '\"', dryRun) &&\n  run('git push origin --tags', dryRun) &&\n  run('npm publish', dryRun) &&\n  run('git rm -r dist', dryRun) &&\n  run('git rm -r bower-packages', dryRun) &&\n  run('git rm index.html', dryRun) &&\n  run('git rm test/in-browser/spec/KefirSpecs.js', dryRun) &&\n  run('git commit -m \"cleanup repository after release\"', dryRun) &&\n  run('git push', dryRun);\n\n});\n\nfunction bumpVersion(fileName, obj, dry) {\n  console.log('Bumping version in `' + fileName + '` to ' + obj.version);\n  if (!dry) {\n    try {\n      fs.writeFileSync(fileName, JSON.stringify(obj, null, '  ') + '\\n');\n      console.log('... ok');\n    } catch(e) {\n      console.error(e);\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction run(cmd, dry){\n  console.log('Running `' + cmd + '`');\n  if (!dry) {\n    if (shell.exec(cmd, {silent:false}).code === 0){\n      console.log('... ok');\n    } else{\n      console.error('... fail!');\n      return false;\n    }\n  }\n  return true;\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/constants.js":"export const NOTHING = ['<nothing>'];\nexport const END = 'end';\nexport const VALUE = 'value';\nexport const ERROR = 'error';\nexport const ANY = 'any';\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/dispatcher.js":"import {extend} from './utils/objects';\nimport {VALUE, ERROR, ANY} from './constants';\nimport {concat, findByPred, remove, contains} from './utils/collections';\n\nfunction callSubscriber(type, fn, event) {\n  if (type === ANY) {\n    fn(event);\n  } else if (type === event.type) {\n    if (type === VALUE || type === ERROR) {\n      fn(event.value);\n    } else {\n      fn();\n    }\n  }\n}\n\nfunction Dispatcher() {\n  this._items = [];\n  this._spies = [];\n  this._inLoop = 0;\n  this._removedItems = null;\n}\n\nextend(Dispatcher.prototype, {\n\n  add(type, fn) {\n    this._items = concat(this._items, [{type, fn}]);\n    return this._items.length;\n  },\n\n  remove(type, fn) {\n    const index = findByPred(this._items, (x) => x.type === type && x.fn === fn);\n\n    // if we're currently in a notification loop,\n    // remember this subscriber was removed\n    if (this._inLoop !== 0 && index !== -1) {\n      if (this._removedItems === null) {\n        this._removedItems = [];\n      }\n      this._removedItems.push(this._items[index]);\n    }\n\n    this._items = remove(this._items, index);\n    return this._items.length;\n  },\n\n\n  addSpy(fn) {\n    this._spies = concat(this._spies, [fn]);\n    return this._spies.length;\n  },\n\n  // Because spies are only ever a function that perform logging as\n  // their only side effect, we don't need the same complicated\n  // removal logic like in remove()\n  removeSpy(fn) {\n    this._spies = remove(this._spies, this._spies.indexOf(fn));\n    return this._spies.length;\n  },\n\n  dispatch(event) {\n    this._inLoop++;\n    for (let i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {\n      spies[i](event);\n    }\n\n    for (let i = 0, items = this._items; i < items.length; i++) {\n\n      // cleanup was called\n      if (this._items === null) {\n        break;\n      }\n\n      // this subscriber was removed\n      if (this._removedItems !== null && contains(this._removedItems, items[i])) {\n        continue;\n      }\n\n      callSubscriber(items[i].type, items[i].fn, event);\n    }\n    this._inLoop--;\n    if (this._inLoop === 0) {\n      this._removedItems = null;\n    }\n  },\n\n  cleanup() {\n    this._items = null;\n    this._spies = null;\n  }\n\n});\n\n\nexport {callSubscriber, Dispatcher};\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/emitter.js":"export default function emitter(obs) {\n\n  function value(x) {\n    obs._emitValue(x);\n    return obs._active;\n  }\n\n  function error(x) {\n    obs._emitError(x);\n    return obs._active;\n  }\n\n  function end() {\n    obs._emitEnd();\n    return obs._active;\n  }\n\n  function event(e) {\n    obs._emit(e.type, e.value);\n    return obs._active;\n  }\n\n  return {\n    value,\n    error,\n    end,\n    event,\n\n    // legacy\n    emit: value,\n    emitEvent: event\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/observable.js":"import {extend} from './utils/objects';\nimport {VALUE, ERROR, ANY, END} from './constants';\nimport {Dispatcher, callSubscriber} from './dispatcher';\nimport {findByPred} from './utils/collections';\n\n\n\nfunction Observable() {\n  this._dispatcher = new Dispatcher();\n  this._active = false;\n  this._alive = true;\n  this._activating = false;\n  this._logHandlers = null;\n  this._spyHandlers = null;\n}\n\nextend(Observable.prototype, {\n\n  _name: 'observable',\n\n  _onActivation() {},\n  _onDeactivation() {},\n\n  _setActive(active) {\n    if (this._active !== active) {\n      this._active = active;\n      if (active) {\n        this._activating = true;\n        this._onActivation();\n        this._activating = false;\n      } else {\n        this._onDeactivation();\n      }\n    }\n  },\n\n  _clear() {\n    this._setActive(false);\n    this._dispatcher.cleanup();\n    this._dispatcher = null;\n    this._logHandlers = null;\n  },\n\n  _emit(type, x) {\n    switch (type) {\n      case VALUE: return this._emitValue(x);\n      case ERROR: return this._emitError(x);\n      case END: return this._emitEnd();\n    }\n  },\n\n  _emitValue(value) {\n    if (this._alive) {\n      this._dispatcher.dispatch({type: VALUE, value});\n    }\n  },\n\n  _emitError(value) {\n    if (this._alive) {\n      this._dispatcher.dispatch({type: ERROR, value});\n    }\n  },\n\n  _emitEnd() {\n    if (this._alive) {\n      this._alive = false\n      this._dispatcher.dispatch({type: END});\n      this._clear();\n    }\n  },\n\n  _on(type, fn) {\n    if (this._alive) {\n      this._dispatcher.add(type, fn);\n      this._setActive(true);\n    } else {\n      callSubscriber(type, fn, {type: END});\n    }\n    return this;\n  },\n\n  _off(type, fn) {\n    if (this._alive) {\n      let count = this._dispatcher.remove(type, fn);\n      if (count === 0) {\n        this._setActive(false);\n      }\n    }\n    return this;\n  },\n\n  onValue(fn) {\n    return this._on(VALUE, fn);\n  },\n  onError(fn) {\n    return this._on(ERROR, fn);\n  },\n  onEnd(fn) {\n    return this._on(END, fn);\n  },\n  onAny(fn) {\n    return this._on(ANY, fn);\n  },\n\n  offValue(fn) {\n    return this._off(VALUE, fn);\n  },\n  offError(fn) {\n    return this._off(ERROR, fn);\n  },\n  offEnd(fn) {\n    return this._off(END, fn);\n  },\n  offAny(fn) {\n    return this._off(ANY, fn);\n  },\n\n  observe(observerOrOnValue, onError, onEnd) {\n    const _this = this;\n    let closed = false;\n\n    const observer = !observerOrOnValue || typeof observerOrOnValue === 'function'\n      ? {value: observerOrOnValue, error: onError, end: onEnd}\n      : observerOrOnValue;\n\n    const handler = function(event) {\n      if (event.type === END) {\n        closed = true;\n      }\n      if (event.type === VALUE && observer.value) {\n        observer.value(event.value);\n      } else if (event.type === ERROR && observer.error) {\n        observer.error(event.value);\n      } else if (event.type === END && observer.end) {\n        observer.end(event.value);\n      }\n    };\n\n    this.onAny(handler);\n\n    return {\n      unsubscribe() {\n        if (!closed) {\n          _this.offAny(handler);\n          closed = true;\n        }\n      },\n      get closed() {\n        return closed;\n      }\n    };\n  },\n\n  // A and B must be subclasses of Stream and Property (order doesn't matter)\n  _ofSameType(A, B) {\n    return A.prototype.getType() === this.getType() ? A : B;\n  },\n\n  setName(sourceObs /* optional */, selfName) {\n    this._name = selfName ? `${sourceObs._name}.${selfName}` : sourceObs;\n    return this;\n  },\n\n\n  log(name = this.toString()) {\n\n    let isCurrent\n    let handler = function(event) {\n      let type = `<${event.type}${isCurrent ? ':current' : ''}>`;\n      if (event.type === END) {\n        console.log(name, type);\n      } else {\n        console.log(name, type, event.value);\n      }\n    };\n\n    if (this._alive) {\n      if (!this._logHandlers) {\n        this._logHandlers = [];\n      }\n      this._logHandlers.push({name: name, handler: handler});\n    }\n\n    isCurrent = true;\n    this.onAny(handler);\n    isCurrent = false;\n\n    return this;\n  },\n\n  offLog(name = this.toString()) {\n\n    if (this._logHandlers) {\n      let handlerIndex = findByPred(this._logHandlers, obj => obj.name === name);\n      if (handlerIndex !== -1) {\n        this.offAny(this._logHandlers[handlerIndex].handler);\n        this._logHandlers.splice(handlerIndex, 1);\n      }\n    }\n\n    return this;\n  },\n\n  spy(name = this.toString()) {\n    let handler = function(event) {\n      let type = `<${event.type}>`;\n      if (event.type === END) {\n        console.log(name, type);\n      } else {\n        console.log(name, type, event.value);\n      }\n    };\n    if (this._alive) {\n      if (!this._spyHandlers) {\n        this._spyHandlers = [];\n      }\n      this._spyHandlers.push({name: name, handler: handler});\n      this._dispatcher.addSpy(handler);\n    }\n    return this;\n  },\n\n  offSpy(name = this.toString()) {\n    if (this._spyHandlers) {\n      let handlerIndex = findByPred(this._spyHandlers, obj => obj.name === name);\n      if (handlerIndex !== -1) {\n        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);\n        this._spyHandlers.splice(handlerIndex, 1);\n      }\n    }\n    return this;\n  }\n});\n\n// extend() can't handle `toString` in IE8\nObservable.prototype.toString = function() {\n  return `[${this._name}]`;\n};\n\n\nexport default Observable;\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/property.js":"import {inherit} from './utils/objects';\nimport {VALUE, ERROR, END} from './constants';\nimport {callSubscriber} from './dispatcher';\nimport Observable from './observable';\n\n\n\nfunction Property() {\n  Observable.call(this);\n  this._currentEvent = null;\n}\n\ninherit(Property, Observable, {\n\n  _name: 'property',\n\n  _emitValue(value) {\n    if (this._alive) {\n      this._currentEvent = {type: VALUE, value};\n      if (!this._activating) {\n        this._dispatcher.dispatch({type: VALUE, value});\n      }\n    }\n  },\n\n  _emitError(value) {\n    if (this._alive) {\n      this._currentEvent = {type: ERROR, value};\n      if (!this._activating) {\n        this._dispatcher.dispatch({type: ERROR, value});\n      }\n    }\n  },\n\n  _emitEnd() {\n    if (this._alive) {\n      this._alive = false\n      if (!this._activating) {\n        this._dispatcher.dispatch({type: END});\n      }\n      this._clear();\n    }\n  },\n\n\n  _on(type, fn) {\n    if (this._alive) {\n      this._dispatcher.add(type, fn);\n      this._setActive(true);\n    }\n    if (this._currentEvent !== null) {\n      callSubscriber(type, fn, this._currentEvent);\n    }\n    if (!this._alive) {\n      callSubscriber(type, fn, {type: END});\n    }\n    return this;\n  },\n\n  getType() {\n    return 'property';\n  }\n\n});\n\nexport default Property;\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/stream.js":"import {inherit} from './utils/objects';\nimport Observable from './observable';\n\n\nfunction Stream() {\n  Observable.call(this);\n}\n\ninherit(Stream, Observable, {\n\n  _name: 'stream',\n\n  getType() {\n    return 'stream';\n  }\n\n});\n\nexport default Stream;\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/interop/from-es-observable.js":"import stream from '../primary/stream';\nimport $$observable from 'symbol-observable';\n\nexport default function fromESObservable(_observable) {\n  const observable = _observable[$$observable] ? _observable[$$observable]() : _observable;\n  return stream(function(emitter) {\n    const unsub = observable.subscribe({\n      error(error) {\n        emitter.error(error);\n        emitter.end();\n      },\n      next(value) {\n        emitter.emit(value);\n      },\n      complete() {\n        emitter.end();\n      }\n    })\n\n    if (unsub.unsubscribe) {\n      return function () { unsub.unsubscribe(); };\n    } else {\n      return unsub;\n    }\n  }).setName('fromESObservable');\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/interop/from-promise.js":"import stream from '../primary/stream';\nimport toProperty from '../one-source/to-property';\n\nexport default function fromPromise(promise) {\n\n  let called = false;\n\n  let result = stream(function(emitter) {\n    if (!called) {\n      let onValue = function(x) {\n        emitter.emit(x);\n        emitter.end();\n      };\n      let onError = function(x) {\n        emitter.error(x);\n        emitter.end();\n      };\n      let _promise = promise.then(onValue, onError);\n\n      // prevent libraries like 'Q' or 'when' from swallowing exceptions\n      if (_promise && typeof _promise.done === 'function') {\n        _promise.done();\n      }\n\n      called = true;\n    }\n  })\n\n  return toProperty(result, null).setName('fromPromise');\n\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/interop/static-land.js":"import constant from '../primary/constant';\nimport never from '../primary/never';\nimport combine from '../many-sources/combine';\n\nconst Observable = {\n\n  empty() {\n    return never();\n  },\n\n  // Monoid based on merge() seems more useful than one based on concat().\n  concat(a, b) {\n    return a.merge(b);\n  },\n\n  of(x) {\n    return constant(x);\n  },\n\n  map(fn, obs) {\n    return obs.map(fn);\n  },\n\n  bimap(fnErr, fnVal, obs) {\n    return obs.mapErrors(fnErr).map(fnVal);\n  },\n\n  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get\n  // different (not very useful) behavior. But spec requires that if method can be derived\n  // it must have the same behavior as hand-written method. We intentionally violate the spec\n  // in hope that it won't cause many troubles in practice. And in return we have more useful type.\n  ap(obsFn, obsVal) {\n    return combine([obsFn, obsVal], (fn, val) => fn(val));\n  },\n\n  chain(fn, obs) {\n    return obs.flatMap(fn);\n  }\n\n}\n\nexport {Observable}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/interop/to-es-observable.js":"import $$observable from 'symbol-observable';\nimport {extend} from '../utils/objects';\nimport {VALUE, ERROR, END} from '../constants';\n\nfunction ESObservable(observable) {\n  this._observable = observable.takeErrors(1);\n}\n\nextend(ESObservable.prototype, {\n  subscribe(observerOrOnNext, onError, onComplete) {\n\n    const observer = typeof observerOrOnNext === 'function'\n      ? {next: observerOrOnNext, error: onError, complete: onComplete}\n      : observerOrOnNext\n\n    const fn = event => {\n      if (event.type === END) {\n        closed = true;\n      }\n\n      if (event.type === VALUE && observer.next) {\n        observer.next(event.value);\n      } else if (event.type === ERROR && observer.error) {\n        observer.error(event.value);\n      } else if (event.type === END && observer.complete) {\n        observer.complete(event.value);\n      }\n    }\n\n    this._observable.onAny(fn);\n    let closed = false\n\n    const subscription = {\n      unsubscribe: () => {\n        closed = true;\n        this._observable.offAny(fn);\n      },\n      get closed() {\n        return closed\n      }\n    };\n    return subscription;\n\n  }\n});\n\n// Need to assign directly b/c Symbols aren't enumerable.\nESObservable.prototype[$$observable] = function() {\n  return this;\n};\n\nexport default function toESObservable() {\n  return new ESObservable(this);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/interop/to-promise.js":"import {VALUE, END} from '../constants';\n\nfunction getGlodalPromise() {\n  if (typeof Promise === 'function') {\n    return Promise;\n  } else {\n    throw new Error('There isn\\'t default Promise, use shim or parameter');\n  }\n}\n\nexport default function(obs, Promise = getGlodalPromise()) {\n  let last = null;\n  return new Promise((resolve, reject) => {\n    obs.onAny(event => {\n      if (event.type === END && last !== null) {\n        (last.type === VALUE ? resolve : reject)(last.value);\n        last = null;\n      } else {\n        last = event;\n      }\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/many-sources/abstract-pool.js":"import Stream from '../stream';\nimport {VALUE, ERROR} from '../constants';\nimport {inherit} from '../utils/objects';\nimport {concat, forEach, findByPred, find, remove, cloneArray} from '../utils/collections';\n\nconst id = (x => x);\n\nfunction AbstractPool({queueLim = 0, concurLim = -1, drop = 'new'} = {}) {\n  Stream.call(this);\n\n  this._queueLim = queueLim < 0 ? -1 : queueLim;\n  this._concurLim = concurLim < 0 ? -1 : concurLim;\n  this._drop = drop;\n  this._queue = [];\n  this._curSources = [];\n  this._$handleSubAny = (event) => this._handleSubAny(event);\n  this._$endHandlers = [];\n  this._currentlyAdding = null;\n\n  if (this._concurLim === 0) {\n    this._emitEnd();\n  }\n}\n\ninherit(AbstractPool, Stream, {\n\n  _name: 'abstractPool',\n\n  _add(obj, toObs /* Function | falsey */) {\n    toObs = toObs || id;\n    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n      this._addToCur(toObs(obj));\n    } else {\n      if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n        this._addToQueue(toObs(obj));\n      } else if (this._drop === 'old') {\n        this._removeOldest();\n        this._add(obj, toObs);\n      }\n    }\n  },\n\n  _addAll(obss) {\n    forEach(obss, (obs) => this._add(obs));\n  },\n\n  _remove(obs) {\n    if (this._removeCur(obs) === -1) {\n      this._removeQueue(obs);\n    }\n  },\n\n  _addToQueue(obs) {\n    this._queue = concat(this._queue, [obs]);\n  },\n\n  _addToCur(obs) {\n    if (this._active) {\n\n      // HACK:\n      //\n      // We have two optimizations for cases when `obs` is ended. We don't want\n      // to add such observable to the list, but only want to emit events\n      // from it (if it has some).\n      //\n      // Instead of this hacks, we could just did following,\n      // but it would be 5-8 times slower:\n      //\n      //     this._curSources = concat(this._curSources, [obs]);\n      //     this._subscribe(obs);\n      //\n\n      // #1\n      // This one for cases when `obs` already ended\n      // e.g., Kefir.constant() or Kefir.never()\n      if (!obs._alive) {\n        if (obs._currentEvent) {\n          this._emit(obs._currentEvent.type, obs._currentEvent.value);\n        }\n        return;\n      }\n\n      // #2\n      // This one is for cases when `obs` going to end synchronously on\n      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n      this._currentlyAdding = obs;\n      obs.onAny(this._$handleSubAny);\n      this._currentlyAdding = null;\n      if (obs._alive) {\n        this._curSources = concat(this._curSources, [obs]);\n        if (this._active) {\n          this._subToEnd(obs);\n        }\n      }\n\n    } else {\n      this._curSources = concat(this._curSources, [obs]);\n    }\n  },\n\n  _subToEnd(obs) {\n    const onEnd = () => this._removeCur(obs);\n    this._$endHandlers.push({obs: obs, handler: onEnd});\n    obs.onEnd(onEnd);\n  },\n\n  _subscribe(obs) {\n    obs.onAny(this._$handleSubAny);\n\n    // it can become inactive in responce of subscribing to `obs.onAny` above\n    if (this._active) {\n      this._subToEnd(obs);\n    }\n  },\n\n  _unsubscribe(obs) {\n    obs.offAny(this._$handleSubAny);\n\n    let onEndI = findByPred(this._$endHandlers, (obj) => obj.obs === obs);\n    if (onEndI !== -1) {\n      obs.offEnd(this._$endHandlers[onEndI].handler);\n      this._$endHandlers.splice(onEndI, 1);\n    }\n  },\n\n  _handleSubAny(event) {\n    if (event.type === VALUE) {\n      this._emitValue(event.value);\n    } else if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n  },\n\n  _removeQueue(obs) {\n    let index = find(this._queue, obs);\n    this._queue = remove(this._queue, index);\n    return index;\n  },\n\n  _removeCur(obs) {\n    if (this._active) {\n      this._unsubscribe(obs);\n    }\n    let index = find(this._curSources, obs);\n    this._curSources = remove(this._curSources, index);\n    if (index !== -1) {\n      if (this._queue.length !== 0) {\n        this._pullQueue();\n      } else if (this._curSources.length === 0) {\n        this._onEmpty();\n      }\n    }\n    return index;\n  },\n\n  _removeOldest() {\n    this._removeCur(this._curSources[0]);\n  },\n\n  _pullQueue() {\n    if (this._queue.length !== 0) {\n      this._queue = cloneArray(this._queue);\n      this._addToCur(this._queue.shift());\n    }\n  },\n\n  _onActivation() {\n    for (let i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n      this._subscribe(sources[i]);\n    }\n  },\n\n  _onDeactivation() {\n    for (let i = 0, sources = this._curSources; i < sources.length; i++) {\n      this._unsubscribe(sources[i]);\n    }\n    if (this._currentlyAdding !== null) {\n      this._unsubscribe(this._currentlyAdding);\n    }\n  },\n\n  _isEmpty() {\n    return this._curSources.length === 0;\n  },\n\n  _onEmpty() {},\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._queue = null;\n    this._curSources = null;\n    this._$handleSubAny = null;\n    this._$endHandlers = null;\n  }\n\n});\n\nexport default AbstractPool;\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/many-sources/combine.js":"import Stream from '../stream';\nimport {VALUE, ERROR, NOTHING} from '../constants';\nimport {inherit} from '../utils/objects';\nimport {concat, fillArray} from '../utils/collections';\nimport {spread} from '../utils/functions';\nimport never from '../primary/never';\n\nfunction collect(source, keys, values) {\n  for (var prop in source) {\n    if( source.hasOwnProperty( prop ) ) {\n      keys.push(prop);\n      values.push(source[prop]);\n    }\n  }\n}\n\nfunction defaultErrorsCombinator(errors) {\n  let latestError;\n  for (let i = 0; i < errors.length; i++) {\n    if (errors[i] !== undefined) {\n      if (latestError === undefined || latestError.index < errors[i].index) {\n        latestError = errors[i];\n      }\n    }\n  }\n  return latestError.error;\n}\n\nfunction Combine(active, passive, combinator) {\n  Stream.call(this);\n  this._activeCount = active.length;\n  this._sources = concat(active, passive);\n  this._combinator = combinator;\n  this._aliveCount = 0;\n  this._latestValues = new Array(this._sources.length);\n  this._latestErrors = new Array(this._sources.length);\n  fillArray(this._latestValues, NOTHING);\n  this._emitAfterActivation = false;\n  this._endAfterActivation = false;\n  this._latestErrorIndex = 0;\n\n  this._$handlers = [];\n  for (let i = 0; i < this._sources.length; i++) {\n    this._$handlers.push((event) => this._handleAny(i, event));\n  }\n\n}\n\n\ninherit(Combine, Stream, {\n\n  _name: 'combine',\n\n  _onActivation() {\n    this._aliveCount = this._activeCount;\n\n    // we need to suscribe to _passive_ sources before _active_\n    // (see https://github.com/rpominov/kefir/issues/98)\n    for (let i = this._activeCount; i < this._sources.length; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n    for (let i = 0; i < this._activeCount; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n\n    if (this._emitAfterActivation) {\n      this._emitAfterActivation = false;\n      this._emitIfFull();\n    }\n    if (this._endAfterActivation) {\n      this._emitEnd();\n    }\n  },\n\n  _onDeactivation() {\n    let length = this._sources.length,\n        i;\n    for (i = 0; i < length; i++) {\n      this._sources[i].offAny(this._$handlers[i]);\n    }\n  },\n\n  _emitIfFull() {\n    let hasAllValues = true;\n    let hasErrors = false;\n    let length = this._latestValues.length;\n    let valuesCopy = new Array(length);\n    let errorsCopy = new Array(length);\n\n    for (let i = 0; i < length; i++) {\n      valuesCopy[i] = this._latestValues[i];\n      errorsCopy[i] = this._latestErrors[i];\n\n      if (valuesCopy[i] === NOTHING) {\n        hasAllValues = false;\n      }\n\n      if (errorsCopy[i] !== undefined) {\n        hasErrors = true;\n      }\n    }\n\n    if (hasAllValues) {\n      const combinator = this._combinator;\n      this._emitValue(combinator(valuesCopy));\n    }\n    if (hasErrors) {\n      this._emitError(defaultErrorsCombinator(errorsCopy));\n    }\n  },\n\n  _handleAny(i, event) {\n\n    if (event.type === VALUE || event.type === ERROR) {\n\n      if (event.type === VALUE) {\n        this._latestValues[i] = event.value;\n        this._latestErrors[i] = undefined;\n      }\n      if (event.type === ERROR) {\n        this._latestValues[i] = NOTHING;\n        this._latestErrors[i] = {\n          index: this._latestErrorIndex++,\n          error: event.value\n        };\n      }\n\n      if (i < this._activeCount) {\n        if (this._activating) {\n          this._emitAfterActivation = true;\n        } else {\n          this._emitIfFull();\n        }\n      }\n\n    } else { // END\n\n      if (i < this._activeCount) {\n        this._aliveCount--;\n        if (this._aliveCount === 0) {\n          if (this._activating) {\n            this._endAfterActivation = true;\n          } else {\n            this._emitEnd();\n          }\n        }\n      }\n\n    }\n  },\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._sources = null;\n    this._latestValues = null;\n    this._latestErrors = null;\n    this._combinator = null;\n    this._$handlers = null;\n  }\n\n});\n\nfunction combineAsArray(active, passive = [], combinator) {\n  if (!Array.isArray(passive)) {\n    throw new Error('Combine can only combine active and passive collections of the same type.');\n  }\n\n  combinator = combinator ? spread(combinator, active.length + passive.length) : (x => x);\n  return active.length === 0 ? never() : new Combine(active, passive, combinator);\n}\n\nfunction combineAsObject(active, passive = {}, combinator) {\n  if (typeof passive !== 'object' || Array.isArray(passive)) {\n    throw new Error('Combine can only combine active and passive collections of the same type.');\n  }\n\n  let keys = [],\n    activeObservables = [],\n    passiveObservables = [];\n\n  collect(active, keys, activeObservables);\n  collect(passive, keys, passiveObservables);\n\n  const objectify = values => {\n    let event = {};\n    for(let i = values.length - 1; 0 <= i; i--) {\n      event[keys[i]] = values[i];\n    }\n    return combinator ? combinator(event) : event;\n  }\n\n  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);\n}\n\nexport default function combine(active, passive, combinator) {\n  if (typeof passive === 'function') {\n    combinator = passive;\n    passive = undefined;\n  }\n\n  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/many-sources/concat.js":"import repeat from './repeat';\n\nexport default function concat(observables) {\n  return repeat(function(index) {\n    return observables.length > index ? observables[index] : false;\n  }).setName('concat');\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/many-sources/flat-map-errors.js":"import {VALUE, ERROR, END} from '../constants';\nimport {inherit} from '../utils/objects';\nimport FlatMap from './flat-map';\n\nfunction FlatMapErrors(source, fn) {\n  FlatMap.call(this, source, fn);\n}\n\ninherit(FlatMapErrors, FlatMap, {\n\n  // Same as in FlatMap, only VALUE/ERROR flipped\n  _handleMain(event) {\n\n    if (event.type === ERROR) {\n      let sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n      if (!sameCurr) {\n        this._add(event.value, this._fn);\n      }\n      this._lastCurrent = event.value;\n      this._hadNoEvSinceDeact = false;\n    }\n\n    if (event.type === VALUE) {\n      this._emitValue(event.value);\n    }\n\n    if (event.type === END) {\n      if (this._isEmpty()) {\n        this._emitEnd();\n      } else {\n        this._mainEnded = true;\n      }\n    }\n\n  }\n\n\n\n});\n\nexport default FlatMapErrors;\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/many-sources/flat-map.js":"import {VALUE, ERROR, END} from '../constants';\nimport {inherit} from '../utils/objects';\nimport AbstractPool from './abstract-pool';\n\n\n\n\nfunction FlatMap(source, fn, options) {\n  AbstractPool.call(this, options);\n  this._source = source;\n  this._fn = fn;\n  this._mainEnded = false;\n  this._lastCurrent = null;\n  this._$handleMain = (event) => this._handleMain(event);\n}\n\ninherit(FlatMap, AbstractPool, {\n\n  _onActivation() {\n    AbstractPool.prototype._onActivation.call(this);\n    if (this._active) {\n      this._source.onAny(this._$handleMain);\n    }\n  },\n\n  _onDeactivation() {\n    AbstractPool.prototype._onDeactivation.call(this);\n    this._source.offAny(this._$handleMain);\n    this._hadNoEvSinceDeact = true;\n  },\n\n  _handleMain(event) {\n\n    if (event.type === VALUE) {\n      // Is latest value before deactivation survived, and now is 'current' on this activation?\n      // We don't want to handle such values, to prevent to constantly add\n      // same observale on each activation/deactivation when our main source\n      // is a `Kefir.conatant()` for example.\n      let sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n      if (!sameCurr) {\n        this._add(event.value, this._fn);\n      }\n      this._lastCurrent = event.value;\n      this._hadNoEvSinceDeact = false;\n    }\n\n    if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n\n    if (event.type === END) {\n      if (this._isEmpty()) {\n        this._emitEnd();\n      } else {\n        this._mainEnded = true;\n      }\n    }\n\n  },\n\n  _onEmpty() {\n    if (this._mainEnded) {\n      this._emitEnd();\n    }\n  },\n\n  _clear() {\n    AbstractPool.prototype._clear.call(this);\n    this._source = null;\n    this._lastCurrent = null;\n    this._$handleMain = null;\n  }\n\n});\n\n\n\n\nexport default FlatMap;\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/many-sources/merge.js":"import {inherit} from '../utils/objects';\nimport AbstractPool from './abstract-pool';\nimport never from '../primary/never';\n\n\nfunction Merge(sources) {\n  AbstractPool.call(this);\n  this._addAll(sources);\n  this._initialised = true;\n}\n\ninherit(Merge, AbstractPool, {\n\n  _name: 'merge',\n\n  _onEmpty() {\n    if (this._initialised) {\n      this._emitEnd();\n    }\n  }\n\n});\n\nexport default function merge(observables) {\n  return observables.length === 0 ? never() : new Merge(observables);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/many-sources/pool.js":"import {inherit} from '../utils/objects';\nimport AbstractPool from './abstract-pool';\n\n\n\nfunction Pool() {\n  AbstractPool.call(this);\n}\n\ninherit(Pool, AbstractPool, {\n\n  _name: 'pool',\n\n  plug(obs) {\n    this._add(obs);\n    return this;\n  },\n\n  unplug(obs) {\n    this._remove(obs);\n    return this;\n  }\n\n});\n\nexport default Pool;\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/many-sources/repeat.js":"import {inherit} from '../utils/objects';\nimport Stream from '../stream';\nimport {END} from '../constants';\n\n\n\nfunction S(generator) {\n  Stream.call(this);\n  this._generator = generator;\n  this._source = null;\n  this._inLoop = false;\n  this._iteration = 0;\n  this._$handleAny = (event) => this._handleAny(event);\n}\n\ninherit(S, Stream, {\n\n  _name: 'repeat',\n\n  _handleAny(event) {\n    if (event.type === END) {\n      this._source = null;\n      this._getSource();\n    } else {\n      this._emit(event.type, event.value);\n    }\n  },\n\n  _getSource() {\n    if (!this._inLoop) {\n      this._inLoop = true;\n      const generator = this._generator;\n      while (this._source === null && this._alive && this._active) {\n        this._source = generator(this._iteration++);\n        if (this._source) {\n          this._source.onAny(this._$handleAny);\n        } else {\n          this._emitEnd();\n        }\n      }\n      this._inLoop = false;\n    }\n  },\n\n  _onActivation() {\n    if (this._source) {\n      this._source.onAny(this._$handleAny);\n    } else {\n      this._getSource();\n    }\n  },\n\n  _onDeactivation() {\n    if (this._source) {\n      this._source.offAny(this._$handleAny);\n    }\n  },\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._generator = null;\n    this._source = null;\n    this._$handleAny = null;\n  }\n\n});\n\n\nexport default function(generator) {\n  return new S(generator);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/many-sources/zip.js":"import Stream from '../stream';\nimport {VALUE, ERROR, END} from '../constants';\nimport {inherit} from '../utils/objects';\nimport {map, cloneArray} from '../utils/collections';\nimport {spread} from '../utils/functions';\nimport never from '../primary/never';\n\n\nconst isArray = Array.isArray || function(xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\nfunction Zip(sources, combinator) {\n  Stream.call(this);\n\n  this._buffers = map(sources, (source) => isArray(source) ? cloneArray(source) : []);\n  this._sources = map(sources, (source) => isArray(source) ? never() : source);\n\n  this._combinator = combinator ? spread(combinator, this._sources.length) : (x => x);\n  this._aliveCount = 0;\n\n  this._$handlers = [];\n  for (let i = 0; i < this._sources.length; i++) {\n    this._$handlers.push((event) => this._handleAny(i, event));\n  }\n}\n\n\ninherit(Zip, Stream, {\n\n  _name: 'zip',\n\n  _onActivation() {\n\n    // if all sources are arrays\n    while (this._isFull()) {\n      this._emit();\n    }\n\n    const length = this._sources.length;\n    this._aliveCount = length;\n    for (let i = 0; i < length && this._active; i++) {\n      this._sources[i].onAny(this._$handlers[i]);\n    }\n  },\n\n  _onDeactivation() {\n    for (let i = 0; i < this._sources.length; i++) {\n      this._sources[i].offAny(this._$handlers[i]);\n    }\n  },\n\n  _emit() {\n    let values = new Array(this._buffers.length);\n    for (let i = 0; i < this._buffers.length; i++) {\n      values[i] = this._buffers[i].shift();\n    }\n    const combinator = this._combinator;\n    this._emitValue(combinator(values));\n  },\n\n  _isFull() {\n    for (let i = 0; i < this._buffers.length; i++) {\n      if (this._buffers[i].length === 0) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  _handleAny(i, event) {\n    if (event.type === VALUE) {\n      this._buffers[i].push(event.value);\n      if (this._isFull()) {\n        this._emit();\n      }\n    }\n    if (event.type === ERROR) {\n      this._emitError(event.value);\n    }\n    if (event.type === END) {\n      this._aliveCount--;\n      if (this._aliveCount === 0) {\n        this._emitEnd();\n      }\n    }\n  },\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._sources = null;\n    this._buffers = null;\n    this._combinator = null;\n    this._$handlers = null;\n  }\n\n});\n\n\n\nexport default function zip(observables, combinator /* Function | falsey */) {\n  return observables.length === 0 ? never() : new Zip(observables, combinator);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/before-end.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleEnd() {\n    const fn = this._fn;\n    this._emitValue(fn());\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('beforeEnd', mixin);\nconst P = createProperty('beforeEnd', mixin);\n\nexport default function beforeEnd(obs, fn) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/buffer-while.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn, flushOnEnd}) {\n    this._fn = fn;\n    this._flushOnEnd = flushOnEnd;\n    this._buff = [];\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null && this._buff.length !== 0) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handleValue(x) {\n    this._buff.push(x);\n    const fn = this._fn;\n    if (!fn(x)) {\n      this._flush();\n    }\n  },\n\n  _handleEnd() {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('bufferWhile', mixin);\nconst P = createProperty('bufferWhile', mixin);\n\n\nconst id = x => x;\n\nexport default function bufferWhile(obs, fn, {flushOnEnd = true} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {fn: fn || id, flushOnEnd});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/buffer-with-count.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({count, flushOnEnd}) {\n    this._count = count;\n    this._flushOnEnd = flushOnEnd;\n    this._buff = [];\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null && this._buff.length !== 0) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handleValue(x) {\n    this._buff.push(x);\n    if (this._buff.length >= this._count) {\n      this._flush();\n    }\n  },\n\n  _handleEnd() {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('bufferWithCount', mixin);\nconst P = createProperty('bufferWithCount', mixin);\n\nexport default function bufferWhile(obs, count, {flushOnEnd = true} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {count: count, flushOnEnd});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/buffer-with-time-or-count.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({wait, count, flushOnEnd}) {\n    this._wait = wait;\n    this._count = count;\n    this._flushOnEnd = flushOnEnd;\n    this._intervalId = null;\n    this._$onTick = () => this._flush();\n    this._buff = [];\n  },\n\n  _free() {\n    this._$onTick = null;\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handleValue(x) {\n    this._buff.push(x);\n    if (this._buff.length >= this._count) {\n      clearInterval(this._intervalId);\n      this._flush();\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    }\n  },\n\n  _handleEnd() {\n    if (this._flushOnEnd && this._buff.length !== 0) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n\n  _onActivation() {\n    this._intervalId = setInterval(this._$onTick, this._wait);\n    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n  },\n\n  _onDeactivation() {\n    if (this._intervalId !== null) {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n    }\n    this._source.offAny(this._$handleAny); // copied from patterns/one-source\n  }\n\n};\n\n\nconst S = createStream('bufferWithTimeOrCount', mixin);\nconst P = createProperty('bufferWithTimeOrCount', mixin);\n\nexport default function bufferWithTimeOrCount(obs, wait, count, {flushOnEnd = true} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {wait, count, flushOnEnd});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/changes.js":"import {createStream} from '../patterns/one-source';\n\n\n\nconst S = createStream('changes', {\n\n  _handleValue(x) {\n    if (!this._activating) {\n      this._emitValue(x);\n    }\n  },\n\n  _handleError(x) {\n    if (!this._activating) {\n      this._emitError(x);\n    }\n  }\n\n});\n\n\nexport default function changes(obs) {\n  return new S(obs);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/debounce.js":"import {createStream, createProperty} from '../patterns/one-source';\nimport now from '../utils/now';\n\n\nconst mixin = {\n\n  _init({wait, immediate}) {\n    this._wait = Math.max(0, wait);\n    this._immediate = immediate;\n    this._lastAttempt = 0;\n    this._timeoutId = null;\n    this._laterValue = null;\n    this._endLater = false;\n    this._$later = () => this._later();\n  },\n\n  _free() {\n    this._laterValue = null;\n    this._$later = null;\n  },\n\n  _handleValue(x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      this._lastAttempt = now();\n      if (this._immediate && !this._timeoutId) {\n        this._emitValue(x);\n      }\n      if (!this._timeoutId) {\n        this._timeoutId = setTimeout(this._$later, this._wait);\n      }\n      if (!this._immediate) {\n        this._laterValue = x;\n      }\n    }\n  },\n\n  _handleEnd() {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      if (this._timeoutId && !this._immediate) {\n        this._endLater = true;\n      } else {\n        this._emitEnd();\n      }\n    }\n  },\n\n  _later() {\n    let last = now() - this._lastAttempt;\n    if (last < this._wait && last >= 0) {\n      this._timeoutId = setTimeout(this._$later, this._wait - last);\n    } else {\n      this._timeoutId = null;\n      if (!this._immediate) {\n        this._emitValue(this._laterValue);\n        this._laterValue = null;\n      }\n      if (this._endLater) {\n        this._emitEnd();\n      }\n    }\n  }\n\n};\n\nconst S = createStream('debounce', mixin);\nconst P = createProperty('debounce', mixin);\n\nexport default function debounce(obs, wait, {immediate = false} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {wait, immediate});\n}\n\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/delay.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst END_MARKER = {};\n\nconst mixin = {\n\n  _init({wait}) {\n    this._wait = Math.max(0, wait);\n    this._buff = [];\n    this._$shiftBuff = () => {\n      const value = this._buff.shift();\n      if (value === END_MARKER) {\n        this._emitEnd();\n      } else {\n        this._emitValue(value);\n      }\n    };\n  },\n\n  _free() {\n    this._buff = null;\n    this._$shiftBuff = null;\n  },\n\n  _handleValue(x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      this._buff.push(x);\n      setTimeout(this._$shiftBuff, this._wait);\n    }\n  },\n\n  _handleEnd() {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      this._buff.push(END_MARKER);\n      setTimeout(this._$shiftBuff, this._wait);\n    }\n  }\n\n};\n\nconst S = createStream('delay', mixin);\nconst P = createProperty('delay', mixin);\n\nexport default function delay(obs, wait) {\n  return new (obs._ofSameType(S, P))(obs, {wait});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/diff.js":"import {createStream, createProperty} from '../patterns/one-source';\nimport {NOTHING} from '../constants';\n\nconst mixin = {\n\n  _init({fn, seed}) {\n    this._fn = fn;\n    this._prev = seed;\n  },\n\n  _free() {\n    this._prev = null;\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    if (this._prev !== NOTHING) {\n      const fn = this._fn;\n      this._emitValue(fn(this._prev, x));\n    }\n    this._prev = x;\n  }\n\n};\n\nconst S = createStream('diff', mixin);\nconst P = createProperty('diff', mixin);\n\n\nfunction defaultFn(a, b) {\n  return [a, b];\n}\n\nexport default function diff(obs, fn, seed = NOTHING) {\n  return new (obs._ofSameType(S, P))(obs, {fn: fn || defaultFn, seed});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/end-on-error.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _handleError(x) {\n    this._emitError(x);\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('endOnError', mixin);\nconst P = createProperty('endOnError', mixin);\n\n\nexport default function endOnError(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/errors-to-values.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleError(x) {\n    const fn = this._fn;\n    const result = fn(x);\n    if (result.convert) {\n      this._emitValue(result.value);\n    } else {\n      this._emitError(x);\n    }\n  }\n\n};\n\nconst S = createStream('errorsToValues', mixin);\nconst P = createProperty('errorsToValues', mixin);\n\n\nconst defFn = x => ({convert: true, value: x});\n\nexport default function errorsToValues(obs, fn = defFn) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/filter-errors.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleError(x) {\n    const fn = this._fn;\n    if (fn(x)) {\n      this._emitError(x);\n    }\n  }\n\n};\n\nconst S = createStream('filterErrors', mixin);\nconst P = createProperty('filterErrors', mixin);\n\n\nconst id = x => x;\n\nexport default function filterErrors(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/filter.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (fn(x)) {\n      this._emitValue(x);\n    }\n  }\n\n};\n\nconst S = createStream('filter', mixin);\nconst P = createProperty('filter', mixin);\n\n\nconst id = x => x;\n\nexport default function filter(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/flatten.js":"import {createStream} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    const xs = fn(x);\n    for (let i = 0; i < xs.length; i++) {\n      this._emitValue(xs[i]);\n    }\n  }\n\n};\n\nconst S = createStream('flatten', mixin);\n\n\nconst id = x => x;\n\nexport default function flatten(obs, fn = id) {\n  return new S(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/ignore-end.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n  _handleEnd() {}\n};\n\nconst S = createStream('ignoreEnd', mixin);\nconst P = createProperty('ignoreEnd', mixin);\n\n\nexport default function ignoreEnd(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/ignore-errors.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n  _handleError() {}\n};\n\nconst S = createStream('ignoreErrors', mixin);\nconst P = createProperty('ignoreErrors', mixin);\n\n\nexport default function ignoreErrors(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/ignore-values.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n  _handleValue() {}\n};\n\nconst S = createStream('ignoreValues', mixin);\nconst P = createProperty('ignoreValues', mixin);\n\n\nexport default function ignoreValues(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/last.js":"import {createStream, createProperty} from '../patterns/one-source';\nimport {NOTHING} from '../constants';\n\nconst mixin = {\n\n  _init() {\n    this._lastValue = NOTHING;\n  },\n\n  _free() {\n    this._lastValue = null;\n  },\n\n  _handleValue(x) {\n    this._lastValue = x;\n  },\n\n  _handleEnd() {\n    if (this._lastValue !== NOTHING) {\n      this._emitValue(this._lastValue);\n    }\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('last', mixin);\nconst P = createProperty('last', mixin);\n\n\nexport default function last(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/map-errors.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleError(x) {\n    const fn = this._fn;\n    this._emitError(fn(x));\n  }\n\n};\n\nconst S = createStream('mapErrors', mixin);\nconst P = createProperty('mapErrors', mixin);\n\n\nconst id = x => x;\n\nexport default function mapErrors(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/map.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    this._emitValue(fn(x));\n  }\n\n};\n\nconst S = createStream('map', mixin);\nconst P = createProperty('map', mixin);\n\n\nconst id = x => x;\n\nexport default function map(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/scan.js":"import {createProperty} from '../patterns/one-source';\nimport {ERROR, NOTHING} from '../constants';\n\n\nconst P = createProperty('scan', {\n\n  _init({fn, seed}) {\n    this._fn = fn;\n    this._seed = seed;\n    if (seed !== NOTHING) {\n      this._emitValue(seed);\n    }\n  },\n\n  _free() {\n    this._fn = null;\n    this._seed = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n    } else {\n      this._emitValue(fn(this._currentEvent.value, x));\n    }\n  }\n\n});\n\n\nexport default function scan(obs, fn, seed = NOTHING) {\n  return new P(obs, {fn, seed});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/skip-duplicates.js":"import {createStream, createProperty} from '../patterns/one-source';\nimport {NOTHING} from '../constants';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n    this._prev = NOTHING;\n  },\n\n  _free() {\n    this._fn = null;\n    this._prev = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (this._prev === NOTHING || !fn(this._prev, x)) {\n      this._prev = x;\n      this._emitValue(x);\n    }\n  }\n\n};\n\nconst S = createStream('skipDuplicates', mixin);\nconst P = createProperty('skipDuplicates', mixin);\n\n\nconst eq = (a, b) => a === b;\n\nexport default function skipDuplicates(obs, fn = eq) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/skip-end.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n  _handleEnd() {}\n};\n\nconst S = createStream('skipEnd', mixin);\nconst P = createProperty('skipEnd', mixin);\n\n\nexport default function skipEnd(obs) {\n  return new (obs._ofSameType(S, P))(obs);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/skip.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({n}) {\n    this._n = Math.max(0, n);\n  },\n\n  _handleValue(x) {\n    if (this._n === 0) {\n      this._emitValue(x);\n    } else {\n      this._n--;\n    }\n  }\n\n};\n\nconst S = createStream('skip', mixin);\nconst P = createProperty('skip', mixin);\n\n\nexport default function skip(obs, n) {\n  return new (obs._ofSameType(S, P))(obs, {n});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/skip-while.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (this._fn !== null && !fn(x)) {\n      this._fn = null;\n    }\n    if (this._fn === null) {\n      this._emitValue(x);\n    }\n  }\n\n};\n\nconst S = createStream('skipWhile', mixin);\nconst P = createProperty('skipWhile', mixin);\n\n\nconst id = x => x;\n\nexport default function skipWhile(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/sliding-window.js":"import {createStream, createProperty} from '../patterns/one-source';\nimport {slide} from '../utils/collections';\n\nconst mixin = {\n\n  _init({min, max}) {\n    this._max = max;\n    this._min = min;\n    this._buff = [];\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _handleValue(x) {\n    this._buff = slide(this._buff, x, this._max);\n    if (this._buff.length >= this._min) {\n      this._emitValue(this._buff);\n    }\n  }\n\n};\n\nconst S = createStream('slidingWindow', mixin);\nconst P = createProperty('slidingWindow', mixin);\n\n\nexport default function slidingWindow(obs, max, min = 0) {\n  return new (obs._ofSameType(S, P))(obs, {min, max});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/take-errors.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({n}) {\n    this._n = n;\n    if (n <= 0) {\n      this._emitEnd();\n    }\n  },\n\n  _handleError(x) {\n    this._n--;\n    this._emitError(x);\n    if (this._n === 0) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('takeErrors', mixin);\nconst P = createProperty('takeErrors', mixin);\n\n\nexport default function takeErrors(obs, n) {\n  return new (obs._ofSameType(S, P))(obs, {n});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/take.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({n}) {\n    this._n = n;\n    if (n <= 0) {\n      this._emitEnd();\n    }\n  },\n\n  _handleValue(x) {\n    this._n--;\n    this._emitValue(x);\n    if (this._n === 0) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('take', mixin);\nconst P = createProperty('take', mixin);\n\n\nexport default function take(obs, n) {\n  return new (obs._ofSameType(S, P))(obs, {n});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/take-while.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    if (fn(x)) {\n      this._emitValue(x);\n    } else {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('takeWhile', mixin);\nconst P = createProperty('takeWhile', mixin);\n\n\nconst id = x => x;\n\nexport default function takeWhile(obs, fn = id) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/throttle.js":"import {createStream, createProperty} from '../patterns/one-source';\nimport now from '../utils/now';\n\n\nconst mixin = {\n\n  _init({wait, leading, trailing}) {\n    this._wait = Math.max(0, wait);\n    this._leading = leading;\n    this._trailing = trailing;\n    this._trailingValue = null;\n    this._timeoutId = null;\n    this._endLater = false;\n    this._lastCallTime = 0;\n    this._$trailingCall = () => this._trailingCall();\n  },\n\n  _free() {\n    this._trailingValue = null;\n    this._$trailingCall = null;\n  },\n\n  _handleValue(x) {\n    if (this._activating) {\n      this._emitValue(x);\n    } else {\n      let curTime = now();\n      if (this._lastCallTime === 0 && !this._leading) {\n        this._lastCallTime = curTime;\n      }\n      let remaining = this._wait - (curTime - this._lastCallTime);\n      if (remaining <= 0) {\n        this._cancelTrailing();\n        this._lastCallTime = curTime;\n        this._emitValue(x);\n      } else if (this._trailing) {\n        this._cancelTrailing();\n        this._trailingValue = x;\n        this._timeoutId = setTimeout(this._$trailingCall, remaining);\n      }\n    }\n  },\n\n  _handleEnd() {\n    if (this._activating) {\n      this._emitEnd();\n    } else {\n      if (this._timeoutId) {\n        this._endLater = true;\n      } else {\n        this._emitEnd();\n      }\n    }\n  },\n\n  _cancelTrailing() {\n    if (this._timeoutId !== null) {\n      clearTimeout(this._timeoutId);\n      this._timeoutId = null;\n    }\n  },\n\n  _trailingCall() {\n    this._emitValue(this._trailingValue);\n    this._timeoutId = null;\n    this._trailingValue = null;\n    this._lastCallTime = !this._leading ? 0 : now();\n    if (this._endLater) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('throttle', mixin);\nconst P = createProperty('throttle', mixin);\n\n\nexport default function throttle(obs, wait, {leading = true, trailing = true} = {}) {\n  return new (obs._ofSameType(S, P))(obs, {wait, leading, trailing});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/to-property.js":"import {createProperty} from '../patterns/one-source';\n\n\nconst P = createProperty('toProperty', {\n\n  _init({fn}) {\n    this._getInitialCurrent = fn;\n  },\n\n  _onActivation() {\n    if (this._getInitialCurrent !== null) {\n      const getInitial = this._getInitialCurrent;\n      this._emitValue(getInitial());\n    }\n    this._source.onAny(this._$handleAny);  // copied from patterns/one-source\n  }\n\n});\n\n\n\nexport default function toProperty(obs, fn = null) {\n  if (fn !== null && typeof fn !== 'function') {\n    throw new Error('You should call toProperty() with a function or no arguments.');\n  }\n  return new P(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/transduce.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nfunction xformForObs(obs) {\n  return {\n\n    '@@transducer/step'(res, input) {\n      obs._emitValue(input);\n      return null;\n    },\n\n    '@@transducer/result'() {\n      obs._emitEnd();\n      return null;\n    }\n\n  };\n}\n\nconst mixin = {\n\n  _init({transducer}) {\n    this._xform = transducer(xformForObs(this));\n  },\n\n  _free() {\n    this._xform = null;\n  },\n\n  _handleValue(x) {\n    if (this._xform['@@transducer/step'](null, x) !== null) {\n      this._xform['@@transducer/result'](null);\n    }\n  },\n\n  _handleEnd() {\n    this._xform['@@transducer/result'](null);\n  }\n\n};\n\nconst S = createStream('transduce', mixin);\nconst P = createProperty('transduce', mixin);\n\n\nexport default function transduce(obs, transducer) {\n  return new (obs._ofSameType(S, P))(obs, {transducer});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/values-to-errors.js":"import {createStream, createProperty} from '../patterns/one-source';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _handleValue(x) {\n    const fn = this._fn;\n    let result = fn(x);\n    if (result.convert) {\n      this._emitError(result.error);\n    } else {\n      this._emitValue(x);\n    }\n  }\n\n};\n\nconst S = createStream('valuesToErrors', mixin);\nconst P = createProperty('valuesToErrors', mixin);\n\n\nconst defFn = x => ({convert: true, error: x});\n\nexport default function valuesToErrors(obs, fn = defFn) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/one-source/with-handler.js":"import {createStream, createProperty} from '../patterns/one-source';\nimport emitter from '../emitter';\n\nconst mixin = {\n\n  _init({fn}) {\n    this._handler = fn;\n    this._emitter = emitter(this);\n  },\n\n  _free() {\n    this._handler = null;\n    this._emitter = null;\n  },\n\n  _handleAny(event) {\n    this._handler(this._emitter, event);\n  }\n\n};\n\nconst S = createStream('withHandler', mixin);\nconst P = createProperty('withHandler', mixin);\n\n\n\nexport default function withHandler(obs, fn) {\n  return new (obs._ofSameType(S, P))(obs, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/patterns/one-source.js":"import Stream from '../stream';\nimport Property from '../property';\nimport {inherit} from '../utils/objects';\nimport {VALUE, ERROR, END} from '../constants';\n\n\nfunction createConstructor(BaseClass, name) {\n  return function AnonymousObservable(source, options) {\n    BaseClass.call(this);\n    this._source = source;\n    this._name = `${source._name}.${name}`;\n    this._init(options);\n    this._$handleAny = (event) => this._handleAny(event);\n  }\n}\n\nfunction createClassMethods(BaseClass) {\n  return {\n\n    _init() {},\n    _free() {},\n\n    _handleValue(x) {\n      this._emitValue(x);\n    },\n    _handleError(x) {\n      this._emitError(x);\n    },\n    _handleEnd() {\n      this._emitEnd();\n    },\n\n    _handleAny(event) {\n      switch (event.type) {\n        case VALUE: return this._handleValue(event.value);\n        case ERROR: return this._handleError(event.value);\n        case END: return this._handleEnd();\n      }\n    },\n\n    _onActivation() {\n      this._source.onAny(this._$handleAny);\n    },\n    _onDeactivation() {\n      this._source.offAny(this._$handleAny);\n    },\n\n    _clear() {\n      BaseClass.prototype._clear.call(this);\n      this._source = null;\n      this._$handleAny = null;\n      this._free();\n    }\n\n  };\n}\n\n\n\nfunction createStream(name, mixin) {\n  const S = createConstructor(Stream, name);\n  inherit(S, Stream, createClassMethods(Stream), mixin);\n  return S;\n}\n\n\nfunction createProperty(name, mixin) {\n  const P = createConstructor(Property, name);\n  inherit(P, Property, createClassMethods(Property), mixin);\n  return P;\n}\n\n\nexport {createStream, createProperty};\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/patterns/time-based.js":"import {inherit} from '../utils/objects';\nimport Stream from '../stream';\n\nexport default function timeBased(mixin) {\n\n  function AnonymousStream(wait, options) {\n    Stream.call(this);\n    this._wait = wait;\n    this._intervalId = null;\n    this._$onTick = () => this._onTick();\n    this._init(options);\n  }\n\n  inherit(AnonymousStream, Stream, {\n\n    _init() {},\n    _free() {},\n\n    _onTick() {},\n\n    _onActivation() {\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    },\n\n    _onDeactivation() {\n      if (this._intervalId !== null) {\n        clearInterval(this._intervalId);\n        this._intervalId = null;\n      }\n    },\n\n    _clear() {\n      Stream.prototype._clear.call(this);\n      this._$onTick = null;\n      this._free();\n    }\n\n  }, mixin);\n\n  return AnonymousStream;\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/patterns/two-sources.js":"import Stream from '../stream';\nimport Property from '../property';\nimport {inherit} from '../utils/objects';\nimport {VALUE, ERROR, END, NOTHING} from '../constants';\n\n\n\n\n\nfunction createConstructor(BaseClass, name) {\n  return function AnonymousObservable(primary, secondary, options) {\n    BaseClass.call(this);\n    this._primary = primary;\n    this._secondary = secondary;\n    this._name = `${primary._name}.${name}`;\n    this._lastSecondary = NOTHING;\n    this._$handleSecondaryAny = (event) => this._handleSecondaryAny(event);\n    this._$handlePrimaryAny = (event) => this._handlePrimaryAny(event);\n    this._init(options);\n  }\n}\n\nfunction createClassMethods(BaseClass) {\n  return {\n    _init() {},\n    _free() {},\n\n    _handlePrimaryValue(x) {\n      this._emitValue(x);\n    },\n    _handlePrimaryError(x) {\n      this._emitError(x);\n    },\n    _handlePrimaryEnd() {\n      this._emitEnd();\n    },\n\n    _handleSecondaryValue(x) {\n      this._lastSecondary = x;\n    },\n    _handleSecondaryError(x) {\n      this._emitError(x);\n    },\n    _handleSecondaryEnd() {},\n\n    _handlePrimaryAny(event) {\n      switch (event.type) {\n        case VALUE: return this._handlePrimaryValue(event.value);\n        case ERROR: return this._handlePrimaryError(event.value);\n        case END: return this._handlePrimaryEnd(event.value);\n      }\n    },\n    _handleSecondaryAny(event) {\n      switch (event.type) {\n        case VALUE: return this._handleSecondaryValue(event.value);\n        case ERROR: return this._handleSecondaryError(event.value);\n        case END:\n          this._handleSecondaryEnd(event.value);\n          this._removeSecondary();\n      }\n    },\n\n    _removeSecondary() {\n      if (this._secondary !== null) {\n        this._secondary.offAny(this._$handleSecondaryAny);\n        this._$handleSecondaryAny = null;\n        this._secondary = null;\n      }\n    },\n\n    _onActivation() {\n      if (this._secondary !== null) {\n        this._secondary.onAny(this._$handleSecondaryAny);\n      }\n      if (this._active) {\n        this._primary.onAny(this._$handlePrimaryAny);\n      }\n    },\n    _onDeactivation() {\n      if (this._secondary !== null) {\n        this._secondary.offAny(this._$handleSecondaryAny);\n      }\n      this._primary.offAny(this._$handlePrimaryAny);\n    },\n\n    _clear() {\n      BaseClass.prototype._clear.call(this);\n      this._primary = null;\n      this._secondary = null;\n      this._lastSecondary = null;\n      this._$handleSecondaryAny = null;\n      this._$handlePrimaryAny = null;\n      this._free();\n    }\n\n  };\n}\n\n\n\nfunction createStream(name, mixin) {\n  const S = createConstructor(Stream, name);\n  inherit(S, Stream, createClassMethods(Stream), mixin);\n  return S;\n}\n\n\nfunction createProperty(name, mixin) {\n  const P = createConstructor(Property, name);\n  inherit(P, Property, createClassMethods(Property), mixin);\n  return P;\n}\n\n\nexport {createStream, createProperty};\n\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/primary/constant-error.js":"import {inherit} from '../utils/objects';\nimport Property from '../property';\n\n\n// HACK:\n//   We don't call parent Class constructor, but instead putting all necessary\n//   properties into prototype to simulate ended Property\n//   (see Propperty and Observable classes).\n\nfunction P(value) {\n  this._currentEvent = {type: 'error', value, current: true};\n}\n\ninherit(P, Property, {\n  _name: 'constantError',\n  _active: false,\n  _activating: false,\n  _alive: false,\n  _dispatcher: null,\n  _logHandlers: null\n});\n\nexport default function constantError(x) {\n  return new P(x);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/primary/constant.js":"import {inherit} from '../utils/objects';\nimport Property from '../property';\n\n// HACK:\n//   We don't call parent Class constructor, but instead putting all necessary\n//   properties into prototype to simulate ended Property\n//   (see Propperty and Observable classes).\n\nfunction P(value) {\n  this._currentEvent = {type: 'value', value, current: true};\n}\n\ninherit(P, Property, {\n  _name: 'constant',\n  _active: false,\n  _activating: false,\n  _alive: false,\n  _dispatcher: null,\n  _logHandlers: null\n});\n\nexport default function constant(x) {\n  return new P(x);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/primary/from-callback.js":"import stream from './stream';\n\nexport default function fromCallback(callbackConsumer) {\n\n  let called = false;\n\n  return stream(function(emitter) {\n\n    if (!called) {\n      callbackConsumer(function(x) {\n        emitter.emit(x);\n        emitter.end();\n      });\n      called = true;\n    }\n\n  }).setName('fromCallback');\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/primary/from-events.js":"import fromSubUnsub from './from-sub-unsub';\n\nconst pairs = [\n  ['addEventListener', 'removeEventListener'],\n  ['addListener', 'removeListener'],\n  ['on', 'off']\n];\n\nexport default function fromEvents(target, eventName, transformer) {\n  let sub, unsub;\n\n  for (let i = 0; i < pairs.length; i++) {\n    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n      sub = pairs[i][0];\n      unsub = pairs[i][1];\n      break;\n    }\n  }\n\n  if (sub === undefined) {\n    throw new Error('target don\\'t support any of ' +\n      'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n  }\n\n  return fromSubUnsub(\n    (handler) => target[sub](eventName, handler),\n    (handler) => target[unsub](eventName, handler),\n    transformer\n  ).setName('fromEvents');\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/primary/from-node-callback.js":"import stream from './stream';\n\nexport default function fromNodeCallback(callbackConsumer) {\n\n  let called = false;\n\n  return stream(function(emitter) {\n\n    if (!called) {\n      callbackConsumer(function(error, x) {\n        if (error) {\n          emitter.error(error);\n        } else {\n          emitter.emit(x);\n        }\n        emitter.end();\n      });\n      called = true;\n    }\n\n  }).setName('fromNodeCallback');\n\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/primary/from-sub-unsub.js":"import stream from './stream';\nimport {apply} from '../utils/functions';\n\nexport default function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n  return stream(function(emitter) {\n\n    let handler = transformer\n      ? function() {\n        emitter.emit(apply(transformer, this, arguments));\n      }\n      : x => {\n        emitter.emit(x)\n      };\n\n    sub(handler);\n    return () => unsub(handler);\n\n  }).setName('fromSubUnsub');\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/primary/never.js":"import Stream from '../stream';\n\n\nconst neverS = new Stream();\nneverS._emitEnd();\nneverS._name = 'never';\n\nexport default function never() {\n  return neverS;\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/primary/stream.js":"import {inherit} from '../utils/objects';\nimport Stream from '../stream';\nimport emitter from '../emitter';\n\nfunction S(fn) {\n  Stream.call(this);\n  this._fn = fn;\n  this._unsubscribe = null;\n}\n\ninherit(S, Stream, {\n\n  _name: 'stream',\n\n  _onActivation() {\n    const fn = this._fn;\n    const unsubscribe = fn(emitter(this));\n    this._unsubscribe = (typeof unsubscribe === 'function') ? unsubscribe : null;\n\n    // fix https://github.com/rpominov/kefir/issues/35\n    if (!this._active) {\n      this._callUnsubscribe();\n    }\n  },\n\n  _callUnsubscribe() {\n    if (this._unsubscribe !== null) {\n      this._unsubscribe();\n      this._unsubscribe = null;\n    }\n  },\n\n  _onDeactivation() {\n    this._callUnsubscribe();\n  },\n\n  _clear() {\n    Stream.prototype._clear.call(this);\n    this._fn = null;\n  }\n\n});\n\nexport default function stream(fn) {\n  return new S(fn);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/time-based/from-poll.js":"import timeBased from '../patterns/time-based';\n\nconst S = timeBased({\n\n  _name: 'fromPoll',\n\n  _init({fn}) {\n    this._fn = fn;\n  },\n\n  _free() {\n    this._fn = null;\n  },\n\n  _onTick() {\n    const fn = this._fn;\n    this._emitValue(fn());\n  }\n\n});\n\n\nexport default function fromPoll(wait, fn) {\n  return new S(wait, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/time-based/interval.js":"import timeBased from '../patterns/time-based';\n\nconst S = timeBased({\n\n  _name: 'interval',\n\n  _init({x}) {\n    this._x = x;\n  },\n\n  _free() {\n    this._x = null;\n  },\n\n  _onTick() {\n    this._emitValue(this._x);\n  }\n\n});\n\n\nexport default function interval(wait, x) {\n  return new S(wait, {x});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/time-based/later.js":"import timeBased from '../patterns/time-based';\n\nconst S = timeBased({\n\n  _name: 'later',\n\n  _init({x}) {\n    this._x = x;\n  },\n\n  _free() {\n    this._x = null;\n  },\n\n  _onTick() {\n    this._emitValue(this._x);\n    this._emitEnd();\n  }\n\n});\n\n\nexport default function later(wait, x) {\n  return new S(wait, {x});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/time-based/sequentially.js":"import timeBased from '../patterns/time-based';\nimport {cloneArray} from '../utils/collections';\nimport never from '../primary/never';\n\nconst S = timeBased({\n\n  _name: 'sequentially',\n\n  _init({xs}) {\n    this._xs = cloneArray(xs);\n  },\n\n  _free() {\n    this._xs = null;\n  },\n\n  _onTick() {\n    if (this._xs.length === 1) {\n      this._emitValue(this._xs[0]);\n      this._emitEnd();\n    } else {\n      this._emitValue(this._xs.shift());\n    }\n  }\n\n});\n\n\nexport default function sequentially(wait, xs) {\n  return xs.length === 0 ? never() : new S(wait, {xs});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/time-based/with-interval.js":"import timeBased from '../patterns/time-based';\nimport emitter from '../emitter';\n\n\nconst S = timeBased({\n\n  _name: 'withInterval',\n\n  _init({fn}) {\n    this._fn = fn;\n    this._emitter = emitter(this);\n  },\n\n  _free() {\n    this._fn = null;\n    this._emitter = null;\n  },\n\n  _onTick() {\n    const fn = this._fn;\n    fn(this._emitter);\n  }\n\n});\n\n\nexport default function withInterval(wait, fn) {\n  return new S(wait, {fn});\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/two-sources/awaiting.js":"import merge from '../many-sources/merge';\nimport map from '../one-source/map';\nimport skipDuplicates from '../one-source/skip-duplicates';\nimport toProperty from '../one-source/to-property';\n\nconst f = () => false;\nconst t = () => true;\n\nexport default function awaiting(a, b) {\n  let result = merge([map(a, t), map(b, f)]);\n  result = skipDuplicates(result);\n  result = toProperty(result, f);\n  return result.setName(a, 'awaiting');\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/two-sources/buffer-by.js":"import {createStream, createProperty} from '../patterns/two-sources';\n\n\nconst mixin = {\n\n  _init({flushOnEnd = true} = {}) {\n    this._buff = [];\n    this._flushOnEnd = flushOnEnd;\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handlePrimaryEnd() {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n\n  _onActivation() {\n    this._primary.onAny(this._$handlePrimaryAny);\n    if (this._alive && this._secondary !== null) {\n      this._secondary.onAny(this._$handleSecondaryAny);\n    }\n  },\n\n  _handlePrimaryValue(x) {\n    this._buff.push(x);\n  },\n\n  _handleSecondaryValue() {\n    this._flush();\n  },\n\n  _handleSecondaryEnd() {\n    if (!this._flushOnEnd) {\n      this._emitEnd();\n    }\n  }\n\n};\n\n\nconst S = createStream('bufferBy', mixin);\nconst P = createProperty('bufferBy', mixin);\n\n\nexport default function bufferBy(primary, secondary, options /* optional */) {\n  return new (primary._ofSameType(S, P))(primary, secondary, options);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/two-sources/buffer-while-by.js":"import {createStream, createProperty} from '../patterns/two-sources';\nimport {NOTHING} from '../constants';\n\n\nconst mixin = {\n\n  _init({flushOnEnd = true, flushOnChange = false} = {}) {\n    this._buff = [];\n    this._flushOnEnd = flushOnEnd;\n    this._flushOnChange = flushOnChange;\n  },\n\n  _free() {\n    this._buff = null;\n  },\n\n  _flush() {\n    if (this._buff !== null) {\n      this._emitValue(this._buff);\n      this._buff = [];\n    }\n  },\n\n  _handlePrimaryEnd() {\n    if (this._flushOnEnd) {\n      this._flush();\n    }\n    this._emitEnd();\n  },\n\n  _handlePrimaryValue(x) {\n    this._buff.push(x);\n    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n      this._flush();\n    }\n  },\n\n  _handleSecondaryEnd() {\n    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n      this._emitEnd();\n    }\n  },\n\n  _handleSecondaryValue(x) {\n    if (this._flushOnChange && !x) {\n      this._flush();\n    }\n\n    // from default _handleSecondaryValue\n    this._lastSecondary = x;\n  }\n\n};\n\n\nconst S = createStream('bufferWhileBy', mixin);\nconst P = createProperty('bufferWhileBy', mixin);\n\n\nexport default function bufferWhileBy(primary, secondary, options /* optional */) {\n  return new (primary._ofSameType(S, P))(primary, secondary, options);\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/two-sources/filter-by.js":"import {createStream, createProperty} from '../patterns/two-sources';\nimport {NOTHING} from '../constants';\n\n\nconst mixin = {\n\n  _handlePrimaryValue(x) {\n    if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n      this._emitValue(x);\n    }\n  },\n\n  _handleSecondaryEnd() {\n    if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('filterBy', mixin);\nconst P = createProperty('filterBy', mixin);\n\n\nexport default function filterBy(primary, secondary) {\n  return new (primary._ofSameType(S, P))(primary, secondary);\n}\n\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/two-sources/sampled-by.js":"import combine from '../many-sources/combine';\n\nconst id2 = (_, x) => x;\n\nexport default function sampledBy(passive, active, combinator) {\n  let _combinator = combinator ? ((a, b) => combinator(b, a)) : id2;\n  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n}\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/two-sources/skip-until-by.js":"import {createStream, createProperty} from '../patterns/two-sources';\nimport {NOTHING} from '../constants';\n\n\nconst mixin = {\n\n  _handlePrimaryValue(x) {\n    if (this._lastSecondary !== NOTHING) {\n      this._emitValue(x);\n    }\n  },\n\n  _handleSecondaryEnd() {\n    if (this._lastSecondary === NOTHING) {\n      this._emitEnd();\n    }\n  }\n\n};\n\nconst S = createStream('skipUntilBy', mixin);\nconst P = createProperty('skipUntilBy', mixin);\n\n\nexport default function skipUntilBy(primary, secondary) {\n  return new (primary._ofSameType(S, P))(primary, secondary);\n}\n\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/two-sources/take-until-by.js":"import {createStream, createProperty} from '../patterns/two-sources';\n\nconst mixin = {\n\n  _handleSecondaryValue() {\n    this._emitEnd();\n  }\n\n};\n\nconst S = createStream('takeUntilBy', mixin);\nconst P = createProperty('takeUntilBy', mixin);\n\n\nexport default function takeUntilBy(primary, secondary) {\n  return new (primary._ofSameType(S, P))(primary, secondary);\n}\n\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/utils/collections.js":"function concat(a, b) {\n  let result, length, i, j;\n  if (a.length === 0) {\n    return b;\n  }\n  if (b.length === 0) {\n    return a;\n  }\n  j = 0;\n  result = new Array(a.length + b.length);\n  length = a.length;\n  for (i = 0; i < length; i++, j++) {\n    result[j] = a[i];\n  }\n  length = b.length;\n  for (i = 0; i < length; i++, j++) {\n    result[j] = b[i];\n  }\n  return result;\n}\n\nfunction circleShift(arr, distance) {\n  let length = arr.length\n    , result = new Array(length)\n    , i;\n  for (i = 0; i < length; i++) {\n    result[(i + distance) % length] = arr[i];\n  }\n  return result;\n}\n\nfunction find(arr, value) {\n  let length = arr.length\n    , i;\n  for (i = 0; i < length; i++) {\n    if (arr[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction findByPred(arr, pred) {\n  let length = arr.length\n    , i;\n  for (i = 0; i < length; i++) {\n    if (pred(arr[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction cloneArray(input) {\n  let length = input.length\n    , result = new Array(length)\n    , i;\n  for (i = 0; i < length; i++) {\n    result[i] = input[i];\n  }\n  return result;\n}\n\nfunction remove(input, index) {\n  let length = input.length\n    , result, i, j;\n  if (index >= 0 && index < length) {\n    if (length === 1) {\n      return [];\n    } else {\n      result = new Array(length - 1);\n      for (i = 0, j = 0; i < length; i++) {\n        if (i !== index) {\n          result[j] = input[i];\n          j++;\n        }\n      }\n      return result;\n    }\n  } else {\n    return input;\n  }\n}\n\nfunction removeByPred(input, pred) {\n  return remove(input, findByPred(input, pred));\n}\n\nfunction map(input, fn) {\n  let length = input.length\n    , result = new Array(length)\n    , i;\n  for (i = 0; i < length; i++) {\n    result[i] = fn(input[i]);\n  }\n  return result;\n}\n\nfunction forEach(arr, fn) {\n  let length = arr.length\n    , i;\n  for (i = 0; i < length; i++) {\n    fn(arr[i]);\n  }\n}\n\nfunction fillArray(arr, value) {\n  let length = arr.length\n    , i;\n  for (i = 0; i < length; i++) {\n    arr[i] = value;\n  }\n}\n\nfunction contains(arr, value) {\n  return find(arr, value) !== -1;\n}\n\nfunction slide(cur, next, max) {\n  let length = Math.min(max, cur.length + 1),\n      offset = cur.length - length + 1,\n      result = new Array(length),\n      i;\n  for (i = offset; i < length; i++) {\n    result[i - offset] = cur[i];\n  }\n  result[length - 1] = next;\n  return result;\n}\n\n\n\n\nexport {\n  concat,\n  circleShift,\n  find,\n  findByPred,\n  cloneArray,\n  remove,\n  removeByPred,\n  map,\n  forEach,\n  fillArray,\n  contains,\n  slide\n};\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/utils/functions.js":"function spread(fn, length) {\n  switch(length) {\n    case 0: return function() {return fn();};\n    case 1: return function(a) {return fn(a[0]);};\n    case 2: return function(a) {return fn(a[0], a[1]);};\n    case 3: return function(a) {return fn(a[0], a[1], a[2]);};\n    case 4: return function(a) {return fn(a[0], a[1], a[2], a[3]);};\n    default: return function(a) {return fn.apply(null, a);};\n  }\n}\n\nfunction apply(fn, c, a) {\n  let aLength = a ? a.length : 0;\n  if (c == null) {\n    switch (aLength) {\n      case 0: return fn();\n      case 1: return fn(a[0]);\n      case 2: return fn(a[0], a[1]);\n      case 3: return fn(a[0], a[1], a[2]);\n      case 4: return fn(a[0], a[1], a[2], a[3]);\n      default: return fn.apply(null, a);\n    }\n  } else {\n    switch (aLength) {\n      case 0: return fn.call(c);\n      default: return fn.apply(c, a);\n    }\n  }\n}\n\nexport {spread, apply};\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/utils/now.js":"export default Date.now ?\n  (() => Date.now()) :\n  (() => new Date().getTime());\n","/home/travis/build/npmtest/node-npmtest-kefir/node_modules/kefir/src/utils/objects.js":"function createObj(proto) {\n  let F = function() {};\n  F.prototype = proto;\n  return new F();\n}\n\nfunction extend(target /*, mixin1, mixin2...*/) {\n  let length = arguments.length\n    , i, prop;\n  for (i = 1; i < length; i++) {\n    for (prop in arguments[i]) {\n      target[prop] = arguments[i][prop];\n    }\n  }\n  return target;\n}\n\nfunction inherit(Child, Parent /*, mixin1, mixin2...*/) {\n  let length = arguments.length\n    , i;\n  Child.prototype = createObj(Parent.prototype);\n  Child.prototype.constructor = Child;\n  for (i = 2; i < length; i++) {\n    extend(Child.prototype, arguments[i]);\n  }\n  return Child;\n}\n\nexport {extend, inherit};\n"}